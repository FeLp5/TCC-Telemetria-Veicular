
# 1 "ff.c"

# 16 "integer.h"
typedef int INT;
typedef unsigned int UINT;


typedef char CHAR;
typedef unsigned char UCHAR;
typedef unsigned char BYTE;


typedef short SHORT;
typedef unsigned short USHORT;
typedef unsigned short WORD;
typedef unsigned short WCHAR;


typedef long LONG;
typedef unsigned long ULONG;
typedef unsigned long DWORD;

# 67 "ff.h"
typedef char TCHAR;

# 78
typedef struct {
BYTE fs_type;
BYTE drv;
BYTE csize;
BYTE n_fats;
BYTE wflag;
BYTE fsi_flag;
WORD id;
WORD n_rootdir;

# 94
DWORD last_clust;
DWORD free_clust;


DWORD cdir;

DWORD n_fatent;
DWORD fsize;
DWORD volbase;
DWORD fatbase;
DWORD dirbase;
DWORD database;
DWORD winsect;
BYTE win[512];
} FATFS;

# 114
typedef struct {
FATFS* fs;
WORD id;
BYTE flag;
BYTE err;
DWORD fptr;
DWORD fsize;
DWORD sclust;
DWORD clust;
DWORD dsect;

DWORD dir_sect;
BYTE* dir_ptr;

# 135
BYTE buf[512];

} FIL;

# 143
typedef struct {
FATFS* fs;
WORD id;
WORD index;
DWORD sclust;
DWORD clust;
DWORD sect;
BYTE* dir;
BYTE* fn;

# 162
} DIR;

# 168
typedef struct {
DWORD fsize;
WORD fdate;
WORD ftime;
BYTE fattrib;
TCHAR fname[13];

# 178
} FILINFO;

# 184
typedef enum {
FR_OK = 0,
FR_DISK_ERR,
FR_INT_ERR,
FR_NOT_READY,
FR_NO_FILE,
FR_NO_PATH,
FR_INVALID_NAME,
FR_DENIED,
FR_EXIST,
FR_INVALID_OBJECT,
FR_WRITE_PROTECTED,
FR_INVALID_DRIVE,
FR_NOT_ENABLED,
FR_NO_FILESYSTEM,
FR_MKFS_ABORTED,
FR_TIMEOUT,
FR_LOCKED,
FR_NOT_ENOUGH_CORE,
FR_TOO_MANY_OPEN_FILES,
FR_INVALID_PARAMETER
} FRESULT;

# 212
FRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);
FRESULT f_close (FIL* fp);
FRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);
FRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);
FRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);
FRESULT f_lseek (FIL* fp, DWORD ofs);
FRESULT f_truncate (FIL* fp);
FRESULT f_sync (FIL* fp);
FRESULT f_opendir (DIR* dp, const TCHAR* path);
FRESULT f_closedir (DIR* dp);
FRESULT f_readdir (DIR* dp, FILINFO* fno);
FRESULT f_findfirst (DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);
FRESULT f_findnext (DIR* dp, FILINFO* fno);
FRESULT f_mkdir (const TCHAR* path);
FRESULT f_unlink (const TCHAR* path);
FRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);
FRESULT f_stat (const TCHAR* path, FILINFO* fno);
FRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);
FRESULT f_utime (const TCHAR* path, const FILINFO* fno);
FRESULT f_chdir (const TCHAR* path);
FRESULT f_chdrive (const TCHAR* path);
FRESULT f_getcwd (TCHAR* buff, UINT len);
FRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);
FRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);
FRESULT f_setlabel (const TCHAR* label);
FRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);
FRESULT f_mkfs (const TCHAR* path, BYTE sfd, UINT au);
FRESULT f_fdisk (BYTE pdrv, const DWORD szt[], void* work);
int f_putc (TCHAR c, FIL* fp);
int f_puts (const TCHAR* str, FIL* cp);
int f_printf (FIL* fp, const TCHAR* str, ...);
TCHAR* f_gets (TCHAR* buff, int len, FIL* fp);

# 264
DWORD get_fattime (void);

# 16 "diskio.h"
typedef BYTE DSTATUS;


typedef enum {
RES_OK = 0,
RES_ERROR,
RES_NOTRDY,
RES_PARERR
} DRESULT;

# 30
DSTATUS disk_initialize (void);
DRESULT disk_readp (BYTE* buff, DWORD sector, UINT offset, UINT count);
DRESULT disk_writep (const BYTE* buff, DWORD sc);

# 448 "ff.c"
static FATFS *FatFs[1];
static WORD Fsid;

# 506
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
BYTE *d = (BYTE*)dst;
const BYTE *s = (const BYTE*)src;

# 518
while (cnt--)
*d++ = *s++;
}


static
void mem_set (void* dst, int val, UINT cnt) {
BYTE *d = (BYTE*)dst;

while (cnt--)
*d++ = (BYTE)val;
}


static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
int r = 0;

while (cnt-- && (r = *d++ - *s++) == 0) ;
return r;
}


static
int chk_chr (const char* str, int chr) {
while (*str && *str != chr) str++;
return *str;
}

# 699
static
FRESULT sync_window (
FATFS* fs
)
{
DWORD wsect;
UINT nf;
FRESULT res = FR_OK;


if (fs->wflag) {
wsect = fs->winsect;
if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
res = FR_DISK_ERR;
} else {
fs->wflag = 0;
if (wsect - fs->fatbase < fs->fsize) {
for (nf = fs->n_fats; nf >= 2; nf--) {
wsect += fs->fsize;
disk_write(fs->drv, fs->win, wsect, 1);
}
}
}
}
return res;
}



static
FRESULT move_window (
FATFS* fs,
DWORD sector
)
{
FRESULT res = FR_OK;


if (sector != fs->winsect) {

res = sync_window(fs);

if (res == FR_OK) {
if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
sector = 0xFFFFFFFF;
res = FR_DISK_ERR;
}
fs->winsect = sector;
}
}
return res;
}

# 759
static
FRESULT sync_fs (
FATFS* fs
)
{
FRESULT res;


res = sync_window(fs);
if (res == FR_OK) {

if (fs->fs_type == 3 && fs->fsi_flag == 1) {

mem_set(fs->win, 0, ((UINT)512));
*(BYTE*)(fs->win + 510)=(BYTE)(0xAA55); *((BYTE*)(fs->win + 510)+1)=(BYTE)((WORD)(0xAA55)>>8);
*(BYTE*)(fs->win + 0)=(BYTE)(0x41615252); *((BYTE*)(fs->win + 0)+1)=(BYTE)((WORD)(0x41615252)>>8); *((BYTE*)(fs->win + 0)+2)=(BYTE)((DWORD)(0x41615252)>>16); *((BYTE*)(fs->win + 0)+3)=(BYTE)((DWORD)(0x41615252)>>24);
*(BYTE*)(fs->win + 484)=(BYTE)(0x61417272); *((BYTE*)(fs->win + 484)+1)=(BYTE)((WORD)(0x61417272)>>8); *((BYTE*)(fs->win + 484)+2)=(BYTE)((DWORD)(0x61417272)>>16); *((BYTE*)(fs->win + 484)+3)=(BYTE)((DWORD)(0x61417272)>>24);
*(BYTE*)(fs->win + 488)=(BYTE)(fs->free_clust); *((BYTE*)(fs->win + 488)+1)=(BYTE)((WORD)(fs->free_clust)>>8); *((BYTE*)(fs->win + 488)+2)=(BYTE)((DWORD)(fs->free_clust)>>16); *((BYTE*)(fs->win + 488)+3)=(BYTE)((DWORD)(fs->free_clust)>>24);
*(BYTE*)(fs->win + 492)=(BYTE)(fs->last_clust); *((BYTE*)(fs->win + 492)+1)=(BYTE)((WORD)(fs->last_clust)>>8); *((BYTE*)(fs->win + 492)+2)=(BYTE)((DWORD)(fs->last_clust)>>16); *((BYTE*)(fs->win + 492)+3)=(BYTE)((DWORD)(fs->last_clust)>>24);

fs->winsect = fs->volbase + 1;
disk_write(fs->drv, fs->win, fs->winsect, 1);
fs->fsi_flag = 0;
}

if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
res = FR_DISK_ERR;
}

return res;
}

# 800
DWORD clust2sect (
FATFS* fs,
DWORD clst
)
{
clst -= 2;
if (clst >= fs->n_fatent - 2) return 0;
return clst * fs->csize + fs->database;
}

# 818
DWORD get_fat (
FATFS* fs,
DWORD clst
)
{
UINT wc, bc;
BYTE *p;
DWORD val;


if (clst < 2 || clst >= fs->n_fatent) {
val = 1;

} else {
val = 0xFFFFFFFF;

switch (fs->fs_type) {
case 1 :
bc = (UINT)clst; bc += bc / 2;
if (move_window(fs, fs->fatbase + (bc / ((UINT)512))) != FR_OK) break;
wc = fs->win[bc++ % ((UINT)512)];
if (move_window(fs, fs->fatbase + (bc / ((UINT)512))) != FR_OK) break;
wc |= fs->win[bc % ((UINT)512)] << 8;
val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
break;

case 2 :
if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 2))) != FR_OK) break;
p = &fs->win[clst * 2 % ((UINT)512)];
val = (WORD)(((WORD)*((BYTE*)(p)+1)<<8)|(WORD)*(BYTE*)(p));
break;

case 3 :
if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4))) != FR_OK) break;
p = &fs->win[clst * 4 % ((UINT)512)];
val = (DWORD)(((DWORD)*((BYTE*)(p)+3)<<24)|((DWORD)*((BYTE*)(p)+2)<<16)|((WORD)*((BYTE*)(p)+1)<<8)|*(BYTE*)(p)) & 0x0FFFFFFF;
break;

default:
val = 1;
}
}

return val;
}

# 873
FRESULT put_fat (
FATFS* fs,
DWORD clst,
DWORD val
)
{
UINT bc;
BYTE *p;
FRESULT res;


if (clst < 2 || clst >= fs->n_fatent) {
res = FR_INT_ERR;

} else {
switch (fs->fs_type) {
case 1 :
bc = (UINT)clst; bc += bc / 2;
res = move_window(fs, fs->fatbase + (bc / ((UINT)512)));
if (res != FR_OK) break;
p = &fs->win[bc++ % ((UINT)512)];
*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
fs->wflag = 1;
res = move_window(fs, fs->fatbase + (bc / ((UINT)512)));
if (res != FR_OK) break;
p = &fs->win[bc % ((UINT)512)];
*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
fs->wflag = 1;
break;

case 2 :
res = move_window(fs, fs->fatbase + (clst / (((UINT)512) / 2)));
if (res != FR_OK) break;
p = &fs->win[clst * 2 % ((UINT)512)];
*(BYTE*)(p)=(BYTE)((WORD)val); *((BYTE*)(p)+1)=(BYTE)((WORD)((WORD)val)>>8);
fs->wflag = 1;
break;

case 3 :
res = move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4)));
if (res != FR_OK) break;
p = &fs->win[clst * 4 % ((UINT)512)];
val |= (DWORD)(((DWORD)*((BYTE*)(p)+3)<<24)|((DWORD)*((BYTE*)(p)+2)<<16)|((WORD)*((BYTE*)(p)+1)<<8)|*(BYTE*)(p)) & 0xF0000000;
*(BYTE*)(p)=(BYTE)(val); *((BYTE*)(p)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(p)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(p)+3)=(BYTE)((DWORD)(val)>>24);
fs->wflag = 1;
break;

default :
res = FR_INT_ERR;
}
}

return res;
}

# 936
static
FRESULT remove_chain (
FATFS* fs,
DWORD clst
)
{
FRESULT res;
DWORD nxt;

# 948
if (clst < 2 || clst >= fs->n_fatent) {
res = FR_INT_ERR;

} else {
res = FR_OK;
while (clst < fs->n_fatent) {
nxt = get_fat(fs, clst);
if (nxt == 0) break;
if (nxt == 1) { res = FR_INT_ERR; break; }
if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
res = put_fat(fs, clst, 0);
if (res != FR_OK) break;
if (fs->free_clust != 0xFFFFFFFF) {
fs->free_clust++;
fs->fsi_flag |= 1;
}

# 974
clst = nxt;
}
}

return res;
}

# 989
static
DWORD create_chain (
FATFS* fs,
DWORD clst
)
{
DWORD cs, ncl, scl;
FRESULT res;


if (clst == 0) {
scl = fs->last_clust;
if (!scl || scl >= fs->n_fatent) scl = 1;
}
else {
cs = get_fat(fs, clst);
if (cs < 2) return 1;
if (cs == 0xFFFFFFFF) return cs;
if (cs < fs->n_fatent) return cs;
scl = clst;
}

ncl = scl;
for (;;) {
ncl++;
if (ncl >= fs->n_fatent) {
ncl = 2;
if (ncl > scl) return 0;
}
cs = get_fat(fs, ncl);
if (cs == 0) break;
if (cs == 0xFFFFFFFF || cs == 1)
return cs;
if (ncl == scl) return 0;
}

res = put_fat(fs, ncl, 0x0FFFFFFF);
if (res == FR_OK && clst != 0) {
res = put_fat(fs, clst, ncl);
}
if (res == FR_OK) {
fs->last_clust = ncl;
if (fs->free_clust != 0xFFFFFFFF) {
fs->free_clust--;
fs->fsi_flag |= 1;
}
} else {
ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
}

return ncl;
}

# 1079
static
FRESULT dir_sdi (
DIR* dp,
UINT idx
)
{
DWORD clst, sect;
UINT ic;


dp->index = (WORD)idx;
clst = dp->sclust;
if (clst == 1 || clst >= dp->fs->n_fatent)
return FR_INT_ERR;
if (!clst && dp->fs->fs_type == 3)
clst = dp->fs->dirbase;

if (clst == 0) {
if (idx >= dp->fs->n_rootdir)
return FR_INT_ERR;
sect = dp->fs->dirbase;
}
else {
ic = ((UINT)512) / 32 * dp->fs->csize;
while (idx >= ic) {
clst = get_fat(dp->fs, clst);
if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
if (clst < 2 || clst >= dp->fs->n_fatent)
return FR_INT_ERR;
idx -= ic;
}
sect = clust2sect(dp->fs, clst);
}
dp->clust = clst;
if (!sect) return FR_INT_ERR;
dp->sect = sect + idx / (((UINT)512) / 32);
dp->dir = dp->fs->win + (idx % (((UINT)512) / 32)) * 32;

return FR_OK;
}

# 1127
static
FRESULT dir_next (
DIR* dp,
int stretch
)
{
DWORD clst;
UINT i;

UINT c;



i = dp->index + 1;
if (!(i & 0xFFFF) || !dp->sect)
return FR_NO_FILE;

if (!(i % (((UINT)512) / 32))) {
dp->sect++;

if (!dp->clust) {
if (i >= dp->fs->n_rootdir)
return FR_NO_FILE;
}
else {
if (((i / (((UINT)512) / 32)) & (dp->fs->csize - 1)) == 0) {
clst = get_fat(dp->fs, dp->clust);
if (clst <= 1) return FR_INT_ERR;
if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
if (clst >= dp->fs->n_fatent) {

if (!stretch) return FR_NO_FILE;
clst = create_chain(dp->fs, dp->clust);
if (clst == 0) return FR_DENIED;
if (clst == 1) return FR_INT_ERR;
if (clst == 0xFFFFFFFF) return FR_DISK_ERR;

if (sync_window(dp->fs)) return FR_DISK_ERR;
mem_set(dp->fs->win, 0, ((UINT)512));
dp->fs->winsect = clust2sect(dp->fs, clst);
for (c = 0; c < dp->fs->csize; c++) {
dp->fs->wflag = 1;
if (sync_window(dp->fs)) return FR_DISK_ERR;
dp->fs->winsect++;
}
dp->fs->winsect -= c;

# 1177
}
dp->clust = clst;
dp->sect = clust2sect(dp->fs, clst);
}
}
}

dp->index = (WORD)i;
dp->dir = dp->fs->win + (i % (((UINT)512) / 32)) * 32;

return FR_OK;
}

# 1198
static
FRESULT dir_alloc (
DIR* dp,
UINT nent
)
{
FRESULT res;
UINT n;


res = dir_sdi(dp, 0);
if (res == FR_OK) {
n = 0;
do {
res = move_window(dp->fs, dp->sect);
if (res != FR_OK) break;
if (dp->dir[0] == 0xE5 || dp->dir[0] == 0) {
if (++n == nent) break;
} else {
n = 0;
}
res = dir_next(dp, 1);
} while (res == FR_OK);
}
if (res == FR_NO_FILE) res = FR_DENIED;
return res;
}

# 1234
static
DWORD ld_clust (
FATFS* fs,
const BYTE* dir
)
{
DWORD cl;

cl = (WORD)(((WORD)*((BYTE*)(dir + 26)+1)<<8)|(WORD)*(BYTE*)(dir + 26));
if (fs->fs_type == 3)
cl |= (DWORD)(WORD)(((WORD)*((BYTE*)(dir + 20)+1)<<8)|(WORD)*(BYTE*)(dir + 20)) << 16;

return cl;
}



static
void st_clust (
BYTE* dir,
DWORD cl
)
{
*(BYTE*)(dir + 26)=(BYTE)(cl); *((BYTE*)(dir + 26)+1)=(BYTE)((WORD)(cl)>>8);
*(BYTE*)(dir + 20)=(BYTE)(cl >> 16); *((BYTE*)(dir + 20)+1)=(BYTE)((WORD)(cl >> 16)>>8);
}

# 1457
static
FRESULT dir_find (
DIR* dp
)
{
FRESULT res;
BYTE c, *dir;

# 1468
res = dir_sdi(dp, 0);
if (res != FR_OK) return res;

# 1474
do {
res = move_window(dp->fs, dp->sect);
if (res != FR_OK) break;
dir = dp->dir;
c = dir[0];
if (c == 0) { res = FR_NO_FILE; break; }

# 1502
if (!(dir[11] & 0x08) && !mem_cmp(dir, dp->fn, 11))
break;

res = dir_next(dp, 0);
} while (res == FR_OK);

return res;
}

# 1518
static
FRESULT dir_read (
DIR* dp,
int vol
)
{
FRESULT res;
BYTE a, c, *dir;

# 1530
res = FR_NO_FILE;
while (dp->sect) {
res = move_window(dp->fs, dp->sect);
if (res != FR_OK) break;
dir = dp->dir;
c = dir[0];
if (c == 0) { res = FR_NO_FILE; break; }
a = dir[11] & 0x3F;

# 1557
if (c != 0xE5 && (2 || c != '.') && a != 0x0F && (int)((a & ~0x20) == 0x08) == vol)
break;

res = dir_next(dp, 0);
if (res != FR_OK) break;
}

if (res != FR_OK) dp->sect = 0;

return res;
}

# 1577
static
FRESULT dir_register (
DIR* dp
)
{
FRESULT res;

# 1629
res = dir_alloc(dp, 1);


if (res == FR_OK) {
res = move_window(dp->fs, dp->sect);
if (res == FR_OK) {
mem_set(dp->dir, 0, 32);
mem_cpy(dp->dir, dp->fn, 11);

# 1640
dp->fs->wflag = 1;
}
}

return res;
}

# 1655
static
FRESULT dir_remove (
DIR* dp
)
{
FRESULT res;

# 1680
res = dir_sdi(dp, dp->index);
if (res == FR_OK) {
res = move_window(dp->fs, dp->sect);
if (res == FR_OK) {
mem_set(dp->dir, 0, 32);
*dp->dir = 0xE5;
dp->fs->wflag = 1;
}
}


return res;
}

# 1702
static
void get_fileinfo (
DIR* dp,
FILINFO* fno
)
{
UINT i;
TCHAR *p, c;
BYTE *dir;

# 1715
p = fno->fname;
if (dp->sect) {
dir = dp->dir;
i = 0;
while (i < 11) {
c = (TCHAR)dir[i++];
if (c == ' ') continue;
if (c == 0x05) c = (TCHAR)0xE5;
if (i == 9) *p++ = '.';

# 1734
*p++ = c;
}
fno->fattrib = dir[11];
fno->fsize = (DWORD)(((DWORD)*((BYTE*)(dir + 28)+3)<<24)|((DWORD)*((BYTE*)(dir + 28)+2)<<16)|((WORD)*((BYTE*)(dir + 28)+1)<<8)|*(BYTE*)(dir + 28));
fno->fdate = (WORD)(((WORD)*((BYTE*)(dir + 24)+1)<<8)|(WORD)*(BYTE*)(dir + 24));
fno->ftime = (WORD)(((WORD)*((BYTE*)(dir + 22)+1)<<8)|(WORD)*(BYTE*)(dir + 22));
}
*p = 0;

# 1762
}

# 1842
static
FRESULT create_name (
DIR* dp,
const TCHAR** path
)
{

# 1969
BYTE b, c, d, *sfn;
UINT ni, si, i;
const char *p;


for (p = *path; *p == '/' || *p == '\\'; p++) ;
sfn = dp->fn;
mem_set(sfn, ' ', 11);
si = i = b = 0; ni = 8;

if (p[si] == '.') {
for (;;) {
c = (BYTE)p[si++];
if (c != '.' || si >= 3) break;
sfn[i++] = c;
}
if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
*path = &p[si];
sfn[11] = (c <= ' ') ? 0x04 | 0x20 : 0x20;
return FR_OK;
}

for (;;) {
c = (BYTE)p[si++];
if (c <= ' ' || c == '/' || c == '\\') break;
if (c == '.' || i >= ni) {
if (ni != 8 || c != '.') return FR_INVALID_NAME;
i = 8; ni = 11;
b <<= 2; continue;
}
if (c >= 0x80) {
b |= 3;




return FR_INVALID_NAME;


}
if (0) {
d = (BYTE)p[si++];
if (!0 || i >= ni - 1)
return FR_INVALID_NAME;
sfn[i++] = c;
sfn[i++] = d;
} else {
if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))
return FR_INVALID_NAME;
if ((((c)>='A')&&((c)<='Z'))) {
b |= 2;
} else {
if ((((c)>='a')&&((c)<='z'))) {
b |= 1; c -= 0x20;
}
}
sfn[i++] = c;
}
}
*path = &p[si];
c = (c <= ' ') ? 0x04 : 0;

if (!i) return FR_INVALID_NAME;
if (sfn[0] == 0xE5) sfn[0] = 0x05;

if (ni == 8) b <<= 2;
if ((b & 0x03) == 0x01) c |= 0x10;
if ((b & 0x0C) == 0x04) c |= 0x08;

sfn[11] = c;

return FR_OK;

}

# 2051
static
FRESULT follow_path (
DIR* dp,
const TCHAR* path
)
{
FRESULT res;
BYTE *dir, ns;



if (*path == '/' || *path == '\\') {
path++; dp->sclust = 0;
} else {
dp->sclust = dp->fs->cdir;
}

# 2073
if ((UINT)*path < ' ') {
res = dir_sdi(dp, 0);
dp->dir = 0;
} else {
for (;;) {
res = create_name(dp, &path);
if (res != FR_OK) break;
res = dir_find(dp);
ns = dp->fn[11];
if (res != FR_OK) {
if (res == FR_NO_FILE) {
if (2 && (ns & 0x20)) {
dp->sclust = 0; dp->dir = 0;
if (!(ns & 0x04)) continue;
res = FR_OK;
} else {
if (!(ns & 0x04)) res = FR_NO_PATH;
}
}
break;
}
if (ns & 0x04) break;
dir = dp->dir;
if (!(dir[11] & 0x10)) {
res = FR_NO_PATH; break;
}
dp->sclust = ld_clust(dp->fs, dir);
}
}

return res;
}

# 2113
static
int get_ldnumber (
const TCHAR** path
)
{
const TCHAR *tp, *tt;
UINT i;
int vol = -1;

# 2129
if (*path) {
for (tt = *path; (UINT)*tt >= (0 ? ' ' : '!') && *tt != ':'; tt++) ;
if (*tt == ':') {
tp = *path;
i = *tp++ - '0';
if (i < 10 && tp == tt) {
if (i < 1) {
vol = (int)i;
*path = ++tt;
}
}

# 2156
return vol;
}



vol = 0;

}
return vol;
}

# 2174
static
BYTE check_fs (
FATFS* fs,
DWORD sect
)
{
fs->wflag = 0; fs->winsect = 0xFFFFFFFF;
if (move_window(fs, sect) != FR_OK)
return 3;

if ((WORD)(((WORD)*((BYTE*)(&fs->win[510])+1)<<8)|(WORD)*(BYTE*)(&fs->win[510])) != 0xAA55)
return 2;

if (((DWORD)(((DWORD)*((BYTE*)(&fs->win[54])+3)<<24)|((DWORD)*((BYTE*)(&fs->win[54])+2)<<16)|((WORD)*((BYTE*)(&fs->win[54])+1)<<8)|*(BYTE*)(&fs->win[54])) & 0xFFFFFF) == 0x544146)
return 0;
if (((DWORD)(((DWORD)*((BYTE*)(&fs->win[82])+3)<<24)|((DWORD)*((BYTE*)(&fs->win[82])+2)<<16)|((WORD)*((BYTE*)(&fs->win[82])+1)<<8)|*(BYTE*)(&fs->win[82])) & 0xFFFFFF) == 0x544146)
return 0;

return 1;
}

# 2202
static
FRESULT find_volume (
FATFS** rfs,
const TCHAR** path,
BYTE wmode
)
{
BYTE fmt, *pt;
int vol;
DSTATUS stat;
DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
WORD nrsv;
FATFS *fs;
UINT i;



*rfs = 0;
vol = get_ldnumber(path);
if (vol < 0) return FR_INVALID_DRIVE;


fs = FatFs[vol];
if (!fs) return FR_NOT_ENABLED;

;
*rfs = fs;

if (fs->fs_type) {
stat = disk_status(fs->drv);
if (!(stat & 0x01)) {
if (!0 && wmode && (stat & STA_PROTECT))
return FR_WRITE_PROTECTED;
return FR_OK;
}
}




fs->fs_type = 0;
fs->drv = (BYTE)(vol);
stat = disk_initialize(fs->drv);
if (stat & 0x01)
return FR_NOT_READY;
if (!0 && wmode && (stat & STA_PROTECT))
return FR_WRITE_PROTECTED;

# 2254
bsect = 0;
fmt = check_fs(fs, bsect);
if (fmt == 1 || (!fmt && (0))) {
for (i = 0; i < 4; i++) {
pt = fs->win + 446 + i * 16;
br[i] = pt[4] ? (DWORD)(((DWORD)*((BYTE*)(&pt[8])+3)<<24)|((DWORD)*((BYTE*)(&pt[8])+2)<<16)|((WORD)*((BYTE*)(&pt[8])+1)<<8)|*(BYTE*)(&pt[8])) : 0;
}
i = 0;
if (i) i--;
do {
bsect = br[i];
fmt = bsect ? check_fs(fs, bsect) : 2;
} while (!0 && fmt && ++i < 4);
}
if (fmt == 3) return FR_DISK_ERR;
if (fmt) return FR_NO_FILESYSTEM;



if ((WORD)(((WORD)*((BYTE*)(fs->win + 11)+1)<<8)|(WORD)*(BYTE*)(fs->win + 11)) != ((UINT)512))
return FR_NO_FILESYSTEM;

fasize = (WORD)(((WORD)*((BYTE*)(fs->win + 22)+1)<<8)|(WORD)*(BYTE*)(fs->win + 22));
if (!fasize) fasize = (DWORD)(((DWORD)*((BYTE*)(fs->win + 36)+3)<<24)|((DWORD)*((BYTE*)(fs->win + 36)+2)<<16)|((WORD)*((BYTE*)(fs->win + 36)+1)<<8)|*(BYTE*)(fs->win + 36));
fs->fsize = fasize;

fs->n_fats = fs->win[16];
if (fs->n_fats != 1 && fs->n_fats != 2)
return FR_NO_FILESYSTEM;
fasize *= fs->n_fats;

fs->csize = fs->win[13];
if (!fs->csize || (fs->csize & (fs->csize - 1)))
return FR_NO_FILESYSTEM;

fs->n_rootdir = (WORD)(((WORD)*((BYTE*)(fs->win + 17)+1)<<8)|(WORD)*(BYTE*)(fs->win + 17));
if (fs->n_rootdir % (((UINT)512) / 32))
return FR_NO_FILESYSTEM;

tsect = (WORD)(((WORD)*((BYTE*)(fs->win + 19)+1)<<8)|(WORD)*(BYTE*)(fs->win + 19));
if (!tsect) tsect = (DWORD)(((DWORD)*((BYTE*)(fs->win + 32)+3)<<24)|((DWORD)*((BYTE*)(fs->win + 32)+2)<<16)|((WORD)*((BYTE*)(fs->win + 32)+1)<<8)|*(BYTE*)(fs->win + 32));

nrsv = (WORD)(((WORD)*((BYTE*)(fs->win + 14)+1)<<8)|(WORD)*(BYTE*)(fs->win + 14));
if (!nrsv) return FR_NO_FILESYSTEM;


sysect = nrsv + fasize + fs->n_rootdir / (((UINT)512) / 32);
if (tsect < sysect) return FR_NO_FILESYSTEM;
nclst = (tsect - sysect) / fs->csize;
if (!nclst) return FR_NO_FILESYSTEM;
fmt = 1;
if (nclst >= 4086U) fmt = 2;
if (nclst >= 65526U) fmt = 3;


fs->n_fatent = nclst + 2;
fs->volbase = bsect;
fs->fatbase = bsect + nrsv;
fs->database = bsect + sysect;
if (fmt == 3) {
if (fs->n_rootdir) return FR_NO_FILESYSTEM;
fs->dirbase = (DWORD)(((DWORD)*((BYTE*)(fs->win + 44)+3)<<24)|((DWORD)*((BYTE*)(fs->win + 44)+2)<<16)|((WORD)*((BYTE*)(fs->win + 44)+1)<<8)|*(BYTE*)(fs->win + 44));
szbfat = fs->n_fatent * 4;
} else {
if (!fs->n_rootdir) return FR_NO_FILESYSTEM;
fs->dirbase = fs->fatbase + fasize;
szbfat = (fmt == 2) ?
fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
}
if (fs->fsize < (szbfat + (((UINT)512) - 1)) / ((UINT)512))
return FR_NO_FILESYSTEM;



fs->last_clust = fs->free_clust = 0xFFFFFFFF;


fs->fsi_flag = 0x80;

if (fmt == 3
&& (WORD)(((WORD)*((BYTE*)(fs->win + 48)+1)<<8)|(WORD)*(BYTE*)(fs->win + 48)) == 1
&& move_window(fs, bsect + 1) == FR_OK)
{
fs->fsi_flag = 0;
if ((WORD)(((WORD)*((BYTE*)(fs->win + 510)+1)<<8)|(WORD)*(BYTE*)(fs->win + 510)) == 0xAA55
&& (DWORD)(((DWORD)*((BYTE*)(fs->win + 0)+3)<<24)|((DWORD)*((BYTE*)(fs->win + 0)+2)<<16)|((WORD)*((BYTE*)(fs->win + 0)+1)<<8)|*(BYTE*)(fs->win + 0)) == 0x41615252
&& (DWORD)(((DWORD)*((BYTE*)(fs->win + 484)+3)<<24)|((DWORD)*((BYTE*)(fs->win + 484)+2)<<16)|((WORD)*((BYTE*)(fs->win + 484)+1)<<8)|*(BYTE*)(fs->win + 484)) == 0x61417272)
{

fs->free_clust = (DWORD)(((DWORD)*((BYTE*)(fs->win + 488)+3)<<24)|((DWORD)*((BYTE*)(fs->win + 488)+2)<<16)|((WORD)*((BYTE*)(fs->win + 488)+1)<<8)|*(BYTE*)(fs->win + 488));


fs->last_clust = (DWORD)(((DWORD)*((BYTE*)(fs->win + 492)+3)<<24)|((DWORD)*((BYTE*)(fs->win + 492)+2)<<16)|((WORD)*((BYTE*)(fs->win + 492)+1)<<8)|*(BYTE*)(fs->win + 492));

}
}


fs->fs_type = fmt;
fs->id = ++Fsid;

fs->cdir = 0;

# 2361
return FR_OK;
}

# 2371
static
FRESULT validate (
void* obj
)
{
FIL *fil = (FIL*)obj;


if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & 0x01))
return FR_INVALID_OBJECT;

;

return FR_OK;
}

# 2402
FRESULT f_mount (
FATFS* fs,
const TCHAR* path,
BYTE opt
)
{
FATFS *cfs;
int vol;
FRESULT res;
const TCHAR *rp = path;


vol = get_ldnumber(&rp);
if (vol < 0) return FR_INVALID_DRIVE;
cfs = FatFs[vol];

if (cfs) {

# 2425
cfs->fs_type = 0;
}

if (fs) {
fs->fs_type = 0;

# 2433
}
FatFs[vol] = fs;

if (!fs || opt != 1) return FR_OK;

res = find_volume(&fs, &path, 0);
return res;
}

# 2449
FRESULT f_open (
FIL* fp,
const TCHAR* path,
BYTE mode
)
{
FRESULT res;
DIR dj;
BYTE *dir;
BYTE sfn[12];

DWORD dw, cl;



if (!fp) return FR_INVALID_OBJECT;
fp->fs = 0;



mode &= 0x01 | 0x02 | 0x08 | 0x10 | 0x04;
res = find_volume(&dj.fs, &path, (BYTE)(mode & ~0x01));

# 2475
if (res == FR_OK) {
(dj).fn = sfn;
res = follow_path(&dj, path);
dir = dj.dir;

if (res == FR_OK) {
if (!dir)
res = FR_INVALID_NAME;

# 2487
}

if (mode & (0x08 | 0x10 | 0x04)) {
if (res != FR_OK) {
if (res == FR_NO_FILE)



res = dir_register(&dj);

mode |= 0x08;
dir = dj.dir;
}
else {
if (dir[11] & (0x01 | 0x10)) {
res = FR_DENIED;
} else {
if (mode & 0x04)
res = FR_EXIST;
}
}
if (res == FR_OK && (mode & 0x08)) {
dw = get_fattime();
*(BYTE*)(dir + 14)=(BYTE)(dw); *((BYTE*)(dir + 14)+1)=(BYTE)((WORD)(dw)>>8); *((BYTE*)(dir + 14)+2)=(BYTE)((DWORD)(dw)>>16); *((BYTE*)(dir + 14)+3)=(BYTE)((DWORD)(dw)>>24);
*(BYTE*)(dir + 22)=(BYTE)(dw); *((BYTE*)(dir + 22)+1)=(BYTE)((WORD)(dw)>>8); *((BYTE*)(dir + 22)+2)=(BYTE)((DWORD)(dw)>>16); *((BYTE*)(dir + 22)+3)=(BYTE)((DWORD)(dw)>>24);
dir[11] = 0;
*(BYTE*)(dir + 28)=(BYTE)(0); *((BYTE*)(dir + 28)+1)=(BYTE)((WORD)(0)>>8); *((BYTE*)(dir + 28)+2)=(BYTE)((DWORD)(0)>>16); *((BYTE*)(dir + 28)+3)=(BYTE)((DWORD)(0)>>24);
cl = ld_clust(dj.fs, dir);
st_clust(dir, 0);
dj.fs->wflag = 1;
if (cl) {
dw = dj.fs->winsect;
res = remove_chain(dj.fs, cl);
if (res == FR_OK) {
dj.fs->last_clust = cl - 1;
res = move_window(dj.fs, dw);
}
}
}
}
else {
if (res == FR_OK) {
if (dir[11] & 0x10) {
res = FR_NO_FILE;
} else {
if ((mode & 0x02) && (dir[11] & 0x01))
res = FR_DENIED;
}
}
}
if (res == FR_OK) {
if (mode & 0x08)
mode |= 0x20;
fp->dir_sect = dj.fs->winsect;
fp->dir_ptr = dir;

# 2546
}

# 2559
;

if (res == FR_OK) {
fp->flag = mode;
fp->err = 0;
fp->sclust = ld_clust(dj.fs, dir);
fp->fsize = (DWORD)(((DWORD)*((BYTE*)(dir + 28)+3)<<24)|((DWORD)*((BYTE*)(dir + 28)+2)<<16)|((WORD)*((BYTE*)(dir + 28)+1)<<8)|*(BYTE*)(dir + 28));
fp->fptr = 0;
fp->dsect = 0;

# 2571
fp->fs = dj.fs;
fp->id = fp->fs->id;
}
}

return res;
}

# 2586
FRESULT f_read (
FIL* fp,
void* buff,
UINT btr,
UINT* br
)
{
FRESULT res;
DWORD clst, sect, remain;
UINT rcnt, cc;
BYTE csect, *rbuff = (BYTE*)buff;


*br = 0;

res = validate(fp);
if (res != FR_OK) return res;
if (fp->err)
return (FRESULT)fp->err;
if (!(fp->flag & 0x01))
return FR_DENIED;
remain = fp->fsize - fp->fptr;
if (btr > remain) btr = (UINT)remain;

for ( ; btr;
rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
if ((fp->fptr % ((UINT)512)) == 0) {
csect = (BYTE)(fp->fptr / ((UINT)512) & (fp->fs->csize - 1));
if (!csect) {
if (fp->fptr == 0) {
clst = fp->sclust;
} else {

# 2623
clst = get_fat(fp->fs, fp->clust);
}
if (clst < 2) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
fp->clust = clst;
}
sect = clust2sect(fp->fs, fp->clust);
if (!sect) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
sect += csect;
cc = btr / ((UINT)512);
if (cc) {
if (csect + cc > fp->fs->csize)
cc = fp->fs->csize - csect;
if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };

# 2643
if ((fp->flag & 0x40) && fp->dsect - sect < cc)
mem_cpy(rbuff + ((fp->dsect - sect) * ((UINT)512)), fp->buf, ((UINT)512));


rcnt = ((UINT)512) * cc;
continue;
}

if (fp->dsect != sect) {

if (fp->flag & 0x40) {
if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
fp->flag &= ~0x40;
}

if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
}

fp->dsect = sect;
}
rcnt = ((UINT)512) - ((UINT)fp->fptr % ((UINT)512));
if (rcnt > btr) rcnt = btr;

# 2672
mem_cpy(rbuff, &fp->buf[fp->fptr % ((UINT)512)], rcnt);

}

return FR_OK;
}

# 2687
FRESULT f_write (
FIL* fp,
const void *buff,
UINT btw,
UINT* bw
)
{
FRESULT res;
DWORD clst, sect;
UINT wcnt, cc;
const BYTE *wbuff = (const BYTE*)buff;
BYTE csect;


*bw = 0;

res = validate(fp);
if (res != FR_OK) return res;
if (fp->err)
return (FRESULT)fp->err;
if (!(fp->flag & 0x02))
return FR_DENIED;
if (fp->fptr + btw < fp->fptr) btw = 0;

for ( ; btw;
wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
if ((fp->fptr % ((UINT)512)) == 0) {
csect = (BYTE)(fp->fptr / ((UINT)512) & (fp->fs->csize - 1));
if (!csect) {
if (fp->fptr == 0) {
clst = fp->sclust;
if (clst == 0)
clst = create_chain(fp->fs, 0);
} else {

# 2726
clst = create_chain(fp->fs, fp->clust);
}
if (clst == 0) break;
if (clst == 1) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
fp->clust = clst;
if (fp->sclust == 0) fp->sclust = clst;
}




if (fp->flag & 0x40) {
if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
fp->flag &= ~0x40;
}

sect = clust2sect(fp->fs, fp->clust);
if (!sect) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
sect += csect;
cc = btw / ((UINT)512);
if (cc) {
if (csect + cc > fp->fs->csize)
cc = fp->fs->csize - csect;
if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };

# 2760
if (fp->dsect - sect < cc) {
mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * ((UINT)512)), ((UINT)512));
fp->flag &= ~0x40;
}


wcnt = ((UINT)512) * cc;
continue;
}

# 2775
if (fp->dsect != sect) {
if (fp->fptr < fp->fsize &&
disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
}

fp->dsect = sect;
}
wcnt = ((UINT)512) - ((UINT)fp->fptr % ((UINT)512));
if (wcnt > btw) wcnt = btw;

# 2791
mem_cpy(&fp->buf[fp->fptr % ((UINT)512)], wbuff, wcnt);
fp->flag |= 0x40;

}

if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;
fp->flag |= 0x20;

return FR_OK;
}

# 2809
FRESULT f_sync (
FIL* fp
)
{
FRESULT res;
DWORD tm;
BYTE *dir;


res = validate(fp);
if (res == FR_OK) {
if (fp->flag & 0x20) {

if (fp->flag & 0x40) {
if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
return FR_DISK_ERR;
fp->flag &= ~0x40;
}


res = move_window(fp->fs, fp->dir_sect);
if (res == FR_OK) {
dir = fp->dir_ptr;
dir[11] |= 0x20;
*(BYTE*)(dir + 28)=(BYTE)(fp->fsize); *((BYTE*)(dir + 28)+1)=(BYTE)((WORD)(fp->fsize)>>8); *((BYTE*)(dir + 28)+2)=(BYTE)((DWORD)(fp->fsize)>>16); *((BYTE*)(dir + 28)+3)=(BYTE)((DWORD)(fp->fsize)>>24);
st_clust(dir, fp->sclust);
tm = get_fattime();
*(BYTE*)(dir + 22)=(BYTE)(tm); *((BYTE*)(dir + 22)+1)=(BYTE)((WORD)(tm)>>8); *((BYTE*)(dir + 22)+2)=(BYTE)((DWORD)(tm)>>16); *((BYTE*)(dir + 22)+3)=(BYTE)((DWORD)(tm)>>24);
*(BYTE*)(dir + 18)=(BYTE)(0); *((BYTE*)(dir + 18)+1)=(BYTE)((WORD)(0)>>8);
fp->flag &= ~0x20;
fp->fs->wflag = 1;
res = sync_fs(fp->fs);
}
}
}

return res;
}

# 2857
FRESULT f_close (
FIL *fp
)
{
FRESULT res;



res = f_sync(fp);
if (res == FR_OK)

{
res = validate(fp);
if (res == FR_OK) {

# 2878
fp->fs = 0;

# 2882
}
}
return res;
}

# 2913
FRESULT f_chdir (
const TCHAR* path
)
{
FRESULT res;
DIR dj;
BYTE sfn[12];



res = find_volume(&dj.fs, &path, 0);
if (res == FR_OK) {
(dj).fn = sfn;
res = follow_path(&dj, path);
;
if (res == FR_OK) {
if (!dj.dir) {
dj.fs->cdir = dj.sclust;
} else {
if (dj.dir[11] & 0x10)
dj.fs->cdir = ld_clust(dj.fs, dj.dir);
else
res = FR_NO_PATH;
}
}
if (res == FR_NO_FILE) res = FR_NO_PATH;
}

return res;
}



FRESULT f_getcwd (
TCHAR* buff,
UINT len
)
{
FRESULT res;
DIR dj;
UINT i, n;
DWORD ccl;
TCHAR *tp;
FILINFO fno;
BYTE sfn[12];


*buff = 0;

res = find_volume(&dj.fs, (const TCHAR**)&buff, 0);
if (res == FR_OK) {
(dj).fn = sfn;
i = len;
dj.sclust = dj.fs->cdir;
while ((ccl = dj.sclust) != 0) {
res = dir_sdi(&dj, 1);
if (res != FR_OK) break;
res = dir_read(&dj, 0);
if (res != FR_OK) break;
dj.sclust = ld_clust(dj.fs, dj.dir);
res = dir_sdi(&dj, 0);
if (res != FR_OK) break;
do {
res = dir_read(&dj, 0);
if (res != FR_OK) break;
if (ccl == ld_clust(dj.fs, dj.dir)) break;
res = dir_next(&dj, 0);
} while (res == FR_OK);
if (res == FR_NO_FILE) res = FR_INT_ERR;
if (res != FR_OK) break;

# 2987
get_fileinfo(&dj, &fno);
tp = fno.fname;

# 2992
for (n = 0; tp[n]; n++) ;
if (i < n + 3) {
res = FR_NOT_ENOUGH_CORE; break;
}
while (n) buff[--i] = tp[--n];
buff[--i] = '/';
}
tp = buff;
if (res == FR_OK) {

# 3005
if (i == len) {
*tp++ = '/';
} else {
do
*tp++ = buff[i++];
while (i < len);
}
}
*tp = 0;
;
}

return res;
}

# 3029
FRESULT f_lseek (
FIL* fp,
DWORD ofs
)
{
FRESULT res;
DWORD clst, bcs, nsect, ifptr;

# 3041
res = validate(fp);
if (res != FR_OK) return res;
if (fp->err)
return (FRESULT)fp->err;

# 3102
{
if (ofs > fp->fsize

&& !(fp->flag & 0x02)

) ofs = fp->fsize;

ifptr = fp->fptr;
fp->fptr = nsect = 0;
if (ofs) {
bcs = (DWORD)fp->fs->csize * ((UINT)512);
if (ifptr > 0 &&
(ofs - 1) / bcs >= (ifptr - 1) / bcs) {
fp->fptr = (ifptr - 1) & ~(bcs - 1);
ofs -= fp->fptr;
clst = fp->clust;
} else {
clst = fp->sclust;

if (clst == 0) {
clst = create_chain(fp->fs, 0);
if (clst == 1) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
fp->sclust = clst;
}

fp->clust = clst;
}
if (clst != 0) {
while (ofs > bcs) {

if (fp->flag & 0x02) {
clst = create_chain(fp->fs, clst);
if (clst == 0) {
ofs = bcs; break;
}
} else

clst = get_fat(fp->fs, clst);
if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
if (clst <= 1 || clst >= fp->fs->n_fatent) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
fp->clust = clst;
fp->fptr += bcs;
ofs -= bcs;
}
fp->fptr += ofs;
if (ofs % ((UINT)512)) {
nsect = clust2sect(fp->fs, clst);
if (!nsect) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
nsect += ofs / ((UINT)512);
}
}
}
if (fp->fptr % ((UINT)512) && nsect != fp->dsect) {


if (fp->flag & 0x40) {
if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
fp->flag &= ~0x40;
}

if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)
{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };

fp->dsect = nsect;
}

if (fp->fptr > fp->fsize) {
fp->fsize = fp->fptr;
fp->flag |= 0x20;
}

}

return res;
}

# 3187
FRESULT f_opendir (
DIR* dp,
const TCHAR* path
)
{
FRESULT res;
FATFS* fs;
BYTE sfn[12];


if (!dp) return FR_INVALID_OBJECT;


res = find_volume(&fs, &path, 0);
if (res == FR_OK) {
dp->fs = fs;
(*dp).fn = sfn;
res = follow_path(dp, path);
;
if (res == FR_OK) {
if (dp->dir) {
if (dp->dir[11] & 0x10)
dp->sclust = ld_clust(fs, dp->dir);
else
res = FR_NO_PATH;
}
if (res == FR_OK) {
dp->id = fs->id;
res = dir_sdi(dp, 0);

# 3227
}
}
if (res == FR_NO_FILE) res = FR_NO_PATH;
}
if (res != FR_OK) dp->fs = 0;

return res;
}

# 3243
FRESULT f_closedir (
DIR *dp
)
{
FRESULT res;


res = validate(dp);
if (res == FR_OK) {

# 3260
dp->fs = 0;

# 3264
}
return res;
}

# 3275
FRESULT f_readdir (
DIR* dp,
FILINFO* fno
)
{
FRESULT res;
BYTE sfn[12];


res = validate(dp);
if (res == FR_OK) {
if (!fno) {
res = dir_sdi(dp, 0);
} else {
(*dp).fn = sfn;
res = dir_read(dp, 0);
if (res == FR_NO_FILE) {
dp->sect = 0;
res = FR_OK;
}
if (res == FR_OK) {
get_fileinfo(dp, fno);
res = dir_next(dp, 0);
if (res == FR_NO_FILE) {
dp->sect = 0;
res = FR_OK;
}
}
;
}
}

return res;
}

# 3369
FRESULT f_stat (
const TCHAR* path,
FILINFO* fno
)
{
FRESULT res;
DIR dj;
BYTE sfn[12];



res = find_volume(&dj.fs, &path, 0);
if (res == FR_OK) {
(dj).fn = sfn;
res = follow_path(&dj, path);
if (res == FR_OK) {
if (dj.dir) {
if (fno) get_fileinfo(&dj, fno);
} else {
res = FR_INVALID_NAME;
}
}
;
}

return res;
}

# 3404
FRESULT f_getfree (
const TCHAR* path,
DWORD* nclst,
FATFS** fatfs
)
{
FRESULT res;
FATFS *fs;
DWORD nfree, clst, sect, stat;
UINT i;
BYTE fat, *p;



res = find_volume(fatfs, &path, 0);
fs = *fatfs;
if (res == FR_OK) {

if (fs->free_clust <= fs->n_fatent - 2) {
*nclst = fs->free_clust;
} else {

fat = fs->fs_type;
nfree = 0;
if (fat == 1) {
clst = 2;
do {
stat = get_fat(fs, clst);
if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
if (stat == 1) { res = FR_INT_ERR; break; }
if (stat == 0) nfree++;
} while (++clst < fs->n_fatent);
} else {
clst = fs->n_fatent; sect = fs->fatbase;
i = 0; p = 0;
do {
if (!i) {
res = move_window(fs, sect++);
if (res != FR_OK) break;
p = fs->win;
i = ((UINT)512);
}
if (fat == 2) {
if ((WORD)(((WORD)*((BYTE*)(p)+1)<<8)|(WORD)*(BYTE*)(p)) == 0) nfree++;
p += 2; i -= 2;
} else {
if (((DWORD)(((DWORD)*((BYTE*)(p)+3)<<24)|((DWORD)*((BYTE*)(p)+2)<<16)|((WORD)*((BYTE*)(p)+1)<<8)|*(BYTE*)(p)) & 0x0FFFFFFF) == 0) nfree++;
p += 4; i -= 4;
}
} while (--clst);
}
fs->free_clust = nfree;
fs->fsi_flag |= 1;
*nclst = nfree;
}
}
return res;
}

# 3470
FRESULT f_truncate (
FIL* fp
)
{
FRESULT res;
DWORD ncl;


res = validate(fp);
if (res == FR_OK) {
if (fp->err) {
res = (FRESULT)fp->err;
} else {
if (!(fp->flag & 0x02))
res = FR_DENIED;
}
}
if (res == FR_OK) {
if (fp->fsize > fp->fptr) {
fp->fsize = fp->fptr;
fp->flag |= 0x20;
if (fp->fptr == 0) {
res = remove_chain(fp->fs, fp->sclust);
fp->sclust = 0;
} else {
ncl = get_fat(fp->fs, fp->clust);
res = FR_OK;
if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
if (ncl == 1) res = FR_INT_ERR;
if (res == FR_OK && ncl < fp->fs->n_fatent) {
res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
if (res == FR_OK) res = remove_chain(fp->fs, ncl);
}
}

if (res == FR_OK && (fp->flag & 0x40)) {
if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
res = FR_DISK_ERR;
else
fp->flag &= ~0x40;
}

}
if (res != FR_OK) fp->err = (FRESULT)res;
}

return res;
}

# 3526
FRESULT f_unlink (
const TCHAR* path
)
{
FRESULT res;
DIR dj, sdj;
BYTE *dir;
DWORD dclst = 0;
BYTE sfn[12];



res = find_volume(&dj.fs, &path, 1);
if (res == FR_OK) {
(dj).fn = sfn;
res = follow_path(&dj, path);
if (2 && res == FR_OK && (dj.fn[11] & 0x20))
res = FR_INVALID_NAME;

# 3547
if (res == FR_OK) {
dir = dj.dir;
if (!dir) {
res = FR_INVALID_NAME;
} else {
if (dir[11] & 0x01)
res = FR_DENIED;
}
if (res == FR_OK) {
dclst = ld_clust(dj.fs, dir);
if (dclst && (dir[11] & 0x10)) {

if (dclst == dj.fs->cdir) {
res = FR_DENIED;
} else

{
mem_cpy(&sdj, &dj, sizeof (DIR));
sdj.sclust = dclst;
res = dir_sdi(&sdj, 2);
if (res == FR_OK) {
res = dir_read(&sdj, 0);
if (res == FR_OK) res = FR_DENIED;
if (res == FR_NO_FILE) res = FR_OK;
}
}
}
}
if (res == FR_OK) {
res = dir_remove(&dj);
if (res == FR_OK && dclst)
res = remove_chain(dj.fs, dclst);
if (res == FR_OK) res = sync_fs(dj.fs);
}
}
;
}

return res;
}

# 3595
FRESULT f_mkdir (
const TCHAR* path
)
{
FRESULT res;
DIR dj;
BYTE *dir, n;
DWORD dsc, dcl, pcl, tm = get_fattime();
BYTE sfn[12];



res = find_volume(&dj.fs, &path, 1);
if (res == FR_OK) {
(dj).fn = sfn;
res = follow_path(&dj, path);
if (res == FR_OK) res = FR_EXIST;
if (2 && res == FR_NO_FILE && (dj.fn[11] & 0x20))
res = FR_INVALID_NAME;
if (res == FR_NO_FILE) {
dcl = create_chain(dj.fs, 0);
res = FR_OK;
if (dcl == 0) res = FR_DENIED;
if (dcl == 1) res = FR_INT_ERR;
if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
if (res == FR_OK)
res = sync_window(dj.fs);
if (res == FR_OK) {
dsc = clust2sect(dj.fs, dcl);
dir = dj.fs->win;
mem_set(dir, 0, ((UINT)512));
mem_set(dir + 0, ' ', 11);
dir[0] = '.';
dir[11] = 0x10;
*(BYTE*)(dir + 22)=(BYTE)(tm); *((BYTE*)(dir + 22)+1)=(BYTE)((WORD)(tm)>>8); *((BYTE*)(dir + 22)+2)=(BYTE)((DWORD)(tm)>>16); *((BYTE*)(dir + 22)+3)=(BYTE)((DWORD)(tm)>>24);
st_clust(dir, dcl);
mem_cpy(dir + 32, dir, 32);
dir[32 + 1] = '.'; pcl = dj.sclust;
if (dj.fs->fs_type == 3 && pcl == dj.fs->dirbase)
pcl = 0;
st_clust(dir + 32, pcl);
for (n = dj.fs->csize; n; n--) {
dj.fs->winsect = dsc++;
dj.fs->wflag = 1;
res = sync_window(dj.fs);
if (res != FR_OK) break;
mem_set(dir, 0, ((UINT)512));
}
}
if (res == FR_OK) res = dir_register(&dj);
if (res != FR_OK) {
remove_chain(dj.fs, dcl);
} else {
dir = dj.dir;
dir[11] = 0x10;
*(BYTE*)(dir + 22)=(BYTE)(tm); *((BYTE*)(dir + 22)+1)=(BYTE)((WORD)(tm)>>8); *((BYTE*)(dir + 22)+2)=(BYTE)((DWORD)(tm)>>16); *((BYTE*)(dir + 22)+3)=(BYTE)((DWORD)(tm)>>24);
st_clust(dir, dcl);
dj.fs->wflag = 1;
res = sync_fs(dj.fs);
}
}
;
}

return res;
}

# 3669
FRESULT f_chmod (
const TCHAR* path,
BYTE attr,
BYTE mask
)
{
FRESULT res;
DIR dj;
BYTE *dir;
BYTE sfn[12];


res = find_volume(&dj.fs, &path, 1);
if (res == FR_OK) {
(dj).fn = sfn;
res = follow_path(&dj, path);
;
if (2 && res == FR_OK && (dj.fn[11] & 0x20))
res = FR_INVALID_NAME;
if (res == FR_OK) {
dir = dj.dir;
if (!dir) {
res = FR_INVALID_NAME;
} else {
mask &= 0x01|0x02|0x04|0x20;
dir[11] = (attr & mask) | (dir[11] & (BYTE)~mask);
dj.fs->wflag = 1;
res = sync_fs(dj.fs);
}
}
}

return res;
}

# 3711
FRESULT f_rename (
const TCHAR* path_old,
const TCHAR* path_new
)
{
FRESULT res;
DIR djo, djn;
BYTE buf[21], *dir;
DWORD dw;
BYTE sfn[12];



res = find_volume(&djo.fs, &path_old, 1);
if (res == FR_OK) {
djn.fs = djo.fs;
(djo).fn = sfn;
res = follow_path(&djo, path_old);
if (2 && res == FR_OK && (djo.fn[11] & 0x20))
res = FR_INVALID_NAME;

# 3734
if (res == FR_OK) {
if (!djo.dir) {
res = FR_NO_FILE;
} else {
mem_cpy(buf, djo.dir + 11, 21);
mem_cpy(&djn, &djo, sizeof (DIR));
if (get_ldnumber(&path_new) >= 0)
res = follow_path(&djn, path_new);
else
res = FR_INVALID_DRIVE;
if (res == FR_OK) res = FR_EXIST;
if (res == FR_NO_FILE) {
res = dir_register(&djn);
if (res == FR_OK) {

dir = djn.dir;
mem_cpy(dir + 13, buf + 2, 19);
dir[11] = buf[0] | 0x20;
djo.fs->wflag = 1;
if ((dir[11] & 0x10) && djo.sclust != djn.sclust) {
dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
if (!dw) {
res = FR_INT_ERR;
} else {
res = move_window(djo.fs, dw);
dir = djo.fs->win + 32 * 1;
if (res == FR_OK && dir[1] == '.') {
st_clust(dir, djn.sclust);
djo.fs->wflag = 1;
}
}
}
if (res == FR_OK) {
res = dir_remove(&djo);
if (res == FR_OK)
res = sync_fs(djo.fs);
}

}
}
}
}
;
}

return res;
}

# 3789
FRESULT f_utime (
const TCHAR* path,
const FILINFO* fno
)
{
FRESULT res;
DIR dj;
BYTE *dir;
BYTE sfn[12];



res = find_volume(&dj.fs, &path, 1);
if (res == FR_OK) {
(dj).fn = sfn;
res = follow_path(&dj, path);
;
if (2 && res == FR_OK && (dj.fn[11] & 0x20))
res = FR_INVALID_NAME;
if (res == FR_OK) {
dir = dj.dir;
if (!dir) {
res = FR_INVALID_NAME;
} else {
*(BYTE*)(dir + 22)=(BYTE)(fno->ftime); *((BYTE*)(dir + 22)+1)=(BYTE)((WORD)(fno->ftime)>>8);
*(BYTE*)(dir + 24)=(BYTE)(fno->fdate); *((BYTE*)(dir + 24)+1)=(BYTE)((WORD)(fno->fdate)>>8);
dj.fs->wflag = 1;
res = sync_fs(dj.fs);
}
}
}

return res;
}

# 3837
FRESULT f_getlabel (
const TCHAR* path,
TCHAR* label,
DWORD* vsn
)
{
FRESULT res;
DIR dj;
UINT i, j;

# 3852
res = find_volume(&dj.fs, &path, 0);


if (res == FR_OK && label) {
dj.sclust = 0;
res = dir_sdi(&dj, 0);
if (res == FR_OK) {
res = dir_read(&dj, 1);
if (res == FR_OK) {

# 3870
mem_cpy(label, dj.dir, 11);

j = 11;
do {
label[j] = 0;
if (!j) break;
} while (label[--j] == ' ');
}
if (res == FR_NO_FILE) {
label[0] = 0;
res = FR_OK;
}
}
}


if (res == FR_OK && vsn) {
res = move_window(dj.fs, dj.fs->volbase);
if (res == FR_OK) {
i = dj.fs->fs_type == 3 ? 67 : 39;
*vsn = (DWORD)(((DWORD)*((BYTE*)(&dj.fs->win[i])+3)<<24)|((DWORD)*((BYTE*)(&dj.fs->win[i])+2)<<16)|((WORD)*((BYTE*)(&dj.fs->win[i])+1)<<8)|*(BYTE*)(&dj.fs->win[i]));
}
}

return res;
}

# 3904
FRESULT f_setlabel (
const TCHAR* label
)
{
FRESULT res;
DIR dj;
BYTE vn[11];
UINT i, j, sl;
WCHAR w;
DWORD tm;



res = find_volume(&dj.fs, &label, 1);
if (res) return res;


vn[0] = 0;
for (sl = 0; label[sl]; sl++) ;
for ( ; sl && label[sl - 1] == ' '; sl--) ;
if (sl) {
i = j = 0;
do {



w = (BYTE)label[i++];
if (0)
w = (j < 10 && i < sl && 0) ? w << 8 | (BYTE)label[i++] : 0;



if ((((w)>='a')&&((w)<='z'))) w -= 0x20;



if (!0 && w >= 0x80) w = 0;



if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11))
return FR_INVALID_NAME;
if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
vn[j++] = (BYTE)w;
} while (i < sl);
while (j < 11) vn[j++] = ' ';
if (vn[0] == 0xE5) return FR_INVALID_NAME;
}


dj.sclust = 0;
res = dir_sdi(&dj, 0);
if (res == FR_OK) {
res = dir_read(&dj, 1);
if (res == FR_OK) {
if (vn[0]) {
mem_cpy(dj.dir, vn, 11);
tm = get_fattime();
*(BYTE*)(dj.dir + 22)=(BYTE)(tm); *((BYTE*)(dj.dir + 22)+1)=(BYTE)((WORD)(tm)>>8); *((BYTE*)(dj.dir + 22)+2)=(BYTE)((DWORD)(tm)>>16); *((BYTE*)(dj.dir + 22)+3)=(BYTE)((DWORD)(tm)>>24);
} else {
dj.dir[0] = 0xE5;
}
dj.fs->wflag = 1;
res = sync_fs(dj.fs);
} else {
if (res == FR_NO_FILE) {
res = FR_OK;
if (vn[0]) {
res = dir_alloc(&dj, 1);
if (res == FR_OK) {
mem_set(dj.dir, 0, 32);
mem_cpy(dj.dir, vn, 11);
dj.dir[11] = 0x08;
tm = get_fattime();
*(BYTE*)(dj.dir + 22)=(BYTE)(tm); *((BYTE*)(dj.dir + 22)+1)=(BYTE)((WORD)(tm)>>8); *((BYTE*)(dj.dir + 22)+2)=(BYTE)((DWORD)(tm)>>16); *((BYTE*)(dj.dir + 22)+3)=(BYTE)((DWORD)(tm)>>24);
dj.fs->wflag = 1;
res = sync_fs(dj.fs);
}
}
}
}
}

return res;
}

# 4382
TCHAR* f_gets (
TCHAR* buff,
int len,
FIL* fp
)
{
int n = 0;
TCHAR c, *p = buff;
BYTE s[2];
UINT rc;


while (n < len - 1) {

# 4439
f_read(fp, s, 1, &rc);
if (rc != 1) break;
c = s[0];

if (1 == 2 && c == '\r') continue;
*p++ = c;
n++;
if (c == '\n') break;
}
*p = 0;
return n ? buff : 0;
}

# 7 "C:\Program Files (x86)\Microchip\xc8\v1.45\include\stdarg.h"
typedef void * va_list[1];

#pragma intrinsic(__va_start)
extern void * __va_start(void);

#pragma intrinsic(__va_arg)
extern void * __va_arg(void *, ...);

# 4461 "ff.c"
typedef struct {
FIL* fp;
int idx, nchr;
BYTE buf[64];
} putbuff;


static
void putc_bfd (
putbuff* pb,
TCHAR c
)
{
UINT bw;
int i;


if (1 == 2 && c == '\n')
putc_bfd(pb, '\r');

i = pb->idx;
if (i < 0) return;

# 4511
pb->buf[i++] = (BYTE)c;


if (i >= (int)(sizeof pb->buf) - 3) {
f_write(pb->fp, pb->buf, (UINT)i, &bw);
i = (bw == (UINT)i) ? 0 : -1;
}
pb->idx = i;
pb->nchr++;
}



int f_putc (
TCHAR c,
FIL* fp
)
{
putbuff pb;
UINT nw;


pb.fp = fp;
pb.nchr = pb.idx = 0;

putc_bfd(&pb, c);

if ( pb.idx >= 0
&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
&& (UINT)pb.idx == nw) return pb.nchr;
return (-1);
}

# 4551
int f_puts (
const TCHAR* str,
FIL* fp
)
{
putbuff pb;
UINT nw;


pb.fp = fp;
pb.nchr = pb.idx = 0;

while (*str)
putc_bfd(&pb, *str++);

if ( pb.idx >= 0
&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
&& (UINT)pb.idx == nw) return pb.nchr;
return (-1);
}

# 4579
int f_printf (
FIL* fp,
const TCHAR* fmt,
...
)
{
va_list arp;
BYTE f, r;
UINT nw, i, j, w;
DWORD v;
TCHAR c, d, s[16], *p;
putbuff pb;


pb.fp = fp;
pb.nchr = pb.idx = 0;

*arp = __va_start();

for (;;) {
c = *fmt++;
if (c == 0) break;
if (c != '%') {
putc_bfd(&pb, c);
continue;
}
w = f = 0;
c = *fmt++;
if (c == '0') {
f = 1; c = *fmt++;
} else {
if (c == '-') {
f = 2; c = *fmt++;
}
}
while ((((c)>='0')&&((c)<='9'))) {
w = w * 10 + c - '0';
c = *fmt++;
}
if (c == 'l' || c == 'L') {
f |= 4; c = *fmt++;
}
if (!c) break;
d = c;
if ((((d)>='a')&&((d)<='z'))) d -= 0x20;
switch (d) {
case 'S' :
p = (*(TCHAR* *)__va_arg((*(TCHAR* **)arp), (TCHAR*)0));
for (j = 0; p[j]; j++) ;
if (!(f & 2)) {
while (j++ < w) putc_bfd(&pb, ' ');
}
while (*p) putc_bfd(&pb, *p++);
while (j++ < w) putc_bfd(&pb, ' ');
continue;
case 'C' :
putc_bfd(&pb, (TCHAR)(*(int *)__va_arg((*(int **)arp), (int)0))); continue;
case 'B' :
r = 2; break;
case 'O' :
r = 8; break;
case 'D' :
case 'U' :
r = 10; break;
case 'X' :
r = 16; break;
default:
putc_bfd(&pb, c); continue;
}


v = (f & 4) ? (DWORD)(*(long *)__va_arg((*(long **)arp), (long)0)) : ((d == 'D') ? (DWORD)(long)(*(int *)__va_arg((*(int **)arp), (int)0)) : (DWORD)(*(unsigned int *)__va_arg((*(unsigned int **)arp), (unsigned int)0)));
if (d == 'D' && (v & 0x80000000)) {
v = 0 - v;
f |= 8;
}
i = 0;
do {
d = (TCHAR)(v % r); v /= r;
if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
s[i++] = d + '0';
} while (v && i < sizeof s / sizeof s[0]);
if (f & 8) s[i++] = '-';
j = i; d = (f & 1) ? '0' : ' ';
while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
do putc_bfd(&pb, s[--i]); while (i);
while (j++ < w) putc_bfd(&pb, d);
}

;

if ( pb.idx >= 0
&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
&& (UINT)pb.idx == nw) return pb.nchr;
return (-1);
}

