
# 1 "mem-mmcsd.c"

# 271 "mem-mmcsd.h"
BYTE spi_rx_dummy_reg;

# 338
typedef enum _FFS_PROCESS_STATE
{
FFS_PROCESS_NO_CARD,
FFS_PROCESS_WAIT_FOR_CARD_FULLY_INSERTED,
FFS_PROCESS_CARD_INITIALSIED
} FFS_PROCESS_STATE;

# 360
BYTE ffs_check_command_response_byte (BYTE mask, BYTE data_requried);

# 367
void ffs_process (void);
BYTE ffs_is_card_present (void);
void ffs_read_sector_to_buffer (DWORD sector_lba);
void ffs_write_sector_from_buffer (DWORD sector_lba);
BYTE ffs_write_byte (BYTE data);
WORD ffs_read_word (void);
BYTE ffs_read_byte (void);

# 406
BYTE sm_ffs_process = FFS_PROCESS_NO_CARD;
WORD file_system_information_sector;
BYTE ffs_no_of_heads;
BYTE ffs_no_of_sectors_per_track;
DWORD ffs_no_of_partition_sectors;
BYTE card_is_high_capacity;
BYTE chk_cmd_response_data;

# 419
WORD number_of_root_directory_sectors;
BYTE ffs_buffer_needs_writing_to_card;
DWORD ffs_buffer_contains_lba = 0xffffffff;
DWORD fat1_start_sector;
DWORD root_directory_start_sector_cluster;
DWORD data_area_start_sector;
BYTE disk_is_fat_32;
BYTE sectors_per_cluster;
DWORD last_found_free_cluster;
DWORD sectors_per_fat;
BYTE active_fat_table_flags;
DWORD read_write_directory_last_lba;
WORD read_write_directory_last_entry;
BYTE ffs_card_write_protected = 0;

# 175 "mem-ffs.h"
typedef struct _FFS_FILE
{
DWORD directory_entry_sector;
BYTE directory_entry_within_sector;
DWORD current_cluster;
BYTE current_sector;
WORD current_byte;
DWORD current_byte_within_file;
DWORD file_size;

union
{
struct
{
unsigned int file_is_open :1;
unsigned int read_permitted :1;
unsigned int write_permitted :1;
unsigned int write_append_only :1;
unsigned int inc_posn_before_next_rw :1;
unsigned int access_error :1;
unsigned int end_of_file :1;
unsigned int file_size_has_changed :1;
unsigned int reserved :8;
} bits;
WORD word;
} flags;

} FFS_FILE;

# 277
extern void ffs_process (void);
extern FFS_FILE* ffs_fopen (const char *filename, const char *access_mode);
extern int ffs_fseek (FFS_FILE *file_pointer, long offset, int origin);
extern int ffs_fsetpos (FFS_FILE *file_pointer, long *position);
extern long ffs_ftell (FFS_FILE *file_pointer);
extern int ffs_fgetpos (FFS_FILE *file_pointer, long *position);
extern void ffs_rewind (FFS_FILE *file_pointer);
extern int ffs_fputc (int data, FFS_FILE *file_pointer);
extern int ffs_fgetc (FFS_FILE *file_pointer);
extern int ffs_fputs (const char *string, FFS_FILE *file_pointer);
extern int ffs_fputs_char (char *string, FFS_FILE *file_pointer);
extern char* ffs_fgets (char *string, int length, FFS_FILE *file_pointer);
extern int ffs_fwrite (const void *buffer, int size, int count, FFS_FILE *file_pointer);
extern int ffs_fread (void *buffer, int size, int count, FFS_FILE *file_pointer);
extern int ffs_fflush (FFS_FILE *file_pointer);
extern int ffs_fclose (FFS_FILE *file_pointer);
extern int ffs_remove (const char *filename);
extern int ffs_change_file_size (const char *filename, DWORD new_file_size);
extern int ffs_rename (const char *old_filename, const char *new_filename);
extern void ffs_clearerr (FFS_FILE *file_pointer);
extern int ffs_feof (FFS_FILE *file_pointer);
extern int ffs_ferror (FFS_FILE *file_pointer);
extern BYTE ffs_is_card_available (void);

# 350
extern FFS_FILE ffs_file[2];
extern BYTE ffs_card_ok;
volatile extern BYTE ffs_10ms_timer;
extern WORD ffs_bytes_per_sector;

# 364
extern BYTE ffs_general_buffer[512];

# 47 "mem-mmcsd.c"
void ffs_process (void)
{
BYTE head;
WORD cylinder_no;
BYTE sector;

BYTE b_temp;
WORD w_temp;
DWORD dw_temp;
DWORD lba;
DWORD main_partition_start_sector;
WORD number_of_reserved_sectors;
BYTE number_of_copies_of_fat;
BYTE *buffer_pointer;


switch (sm_ffs_process)
{
case FFS_PROCESS_NO_CARD:



(1 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));

ffs_card_ok = 0;


for (b_temp = 0; b_temp < 2; b_temp++)
ffs_file[b_temp].flags.bits.file_is_open = 0;


if (ffs_is_card_present() == 0)
return;



ffs_10ms_timer = 50;
sm_ffs_process = FFS_PROCESS_WAIT_FOR_CARD_FULLY_INSERTED;

return;


case FFS_PROCESS_WAIT_FOR_CARD_FULLY_INSERTED:

# 96
if (ffs_is_card_present() == 0)
{
sm_ffs_process = FFS_PROCESS_NO_CARD;
return;
}


if (ffs_10ms_timer)
return;


sm_ffs_process = FFS_PROCESS_CARD_INITIALSIED;


break;

case FFS_PROCESS_CARD_INITIALSIED:

# 118
if (ffs_is_card_present())
return;


ffs_card_ok = 0;

sm_ffs_process = FFS_PROCESS_NO_CARD;

return;


default:
sm_ffs_process = FFS_PROCESS_NO_CARD;
return;
}

# 141
SSP0CPSR = 150;

ffs_card_ok = 0;

(1 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));


for (b_temp = 0; b_temp < 10; b_temp++)
{
ffs_write_byte(0xff);
}

(0 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));



ffs_write_byte(0x40 + 0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0x95);

if (!ffs_check_command_response_byte(0x81, 0x01))
goto init_new_ffs_card_fail;

ffs_write_byte(0xff);
ffs_write_byte(0xff);
ffs_write_byte(0xff);
ffs_write_byte(0xff);
ffs_write_byte(0xff);
ffs_write_byte(0xff);
ffs_write_byte(0xff);
ffs_write_byte(0xff);

# 182
ffs_write_byte(0x40 + 8);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(1);
ffs_write_byte(0xaa);
ffs_write_byte(0x87);


b_temp = ffs_check_command_response_byte(0xff, 0x01);

card_is_high_capacity = 1;

if (b_temp)
{


ffs_read_byte();
ffs_read_byte();
b_temp = ffs_read_byte();
if ((b_temp & 0x0f) != 0x01)
goto init_new_ffs_card_fail;
b_temp = ffs_read_byte();
if (b_temp != 0xaa)
card_is_high_capacity = 0;
}
else
{
card_is_high_capacity = 0;
}
ffs_read_byte();




ffs_write_byte(0x40 + 59);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0x01);
ffs_write_byte(0xff);

ffs_check_command_response_byte(0xff, 0x01);
ffs_read_byte();

# 232
ffs_10ms_timer = 250;
b_temp = 0;
while (1)
{

if(ffs_10ms_timer == 0)
goto init_new_ffs_card_fail;


ffs_write_byte(0x40 + 55);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0x65);

ffs_check_command_response_byte(0x80, 0x00);

b_temp = chk_cmd_response_data;
if (b_temp & 0x04)
goto init_new_ffs_card_init_mmc;

if (b_temp != 0x01)
continue;

ffs_read_byte();



ffs_write_byte(0x40 + 41);
ffs_write_byte(0x40);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0x77);

ffs_check_command_response_byte(0x80, 0x00);

b_temp = chk_cmd_response_data;
if (b_temp & 0x04)
goto init_new_ffs_card_init_mmc;

if (b_temp == 0x00)
break;

ffs_read_byte();

}



ffs_read_byte();

# 296
ffs_10ms_timer = 100;
b_temp = 0;
while ((b_temp & 0x80) == 0)
{

if(ffs_10ms_timer == 0)
goto init_new_ffs_card_fail;

ffs_write_byte(0x40 + 58);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0xfd);

b_temp = ffs_check_command_response_byte(0xff, 0x00);
b_temp = chk_cmd_response_data;
if (b_temp != 0)
{
b_temp = 0;
continue;
}
b_temp = ffs_read_byte();
ffs_read_byte();
ffs_read_byte();
ffs_read_byte();
ffs_read_byte();
}

if (b_temp & 0x40)
{
card_is_high_capacity = 1;
}
else
{
card_is_high_capacity = 0;
}



for (b_temp = 0; b_temp < 3; b_temp++)
{
ffs_write_byte(0x40 + 59);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0x00);
ffs_write_byte(0x91);

ffs_check_command_response_byte(0xff, 0x01);
ffs_read_byte();
}


SSP0CR1 = 0; SSP0CPSR = 4; SSP0CR1 = SSP0CR1_SSE;


goto init_new_ffs_card_init_mmc_done;

# 360
init_new_ffs_card_init_mmc:



card_is_high_capacity = 0;


for (b_temp = 0; b_temp < 3; b_temp++)
{
ffs_write_byte(0x40 + 59);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0x00);
ffs_write_byte(0x91);

ffs_check_command_response_byte(0xff, 0x01);
ffs_read_byte();
}

# 384
ffs_10ms_timer = 250;
b_temp = 0;
while ((b_temp & 0x01) == 0)
{
ffs_write_byte(0x40 + 1);
ffs_write_byte(0x40);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0xff);

b_temp = ffs_check_command_response_byte(0x81, 0x00);
ffs_read_byte();


if(ffs_10ms_timer == 0)
goto init_new_ffs_card_fail;
}

# 414
ffs_10ms_timer = 100;
b_temp = 0;
while ((b_temp & 0x80) == 0)
{

if(ffs_10ms_timer == 0)
goto init_new_ffs_card_fail;

ffs_write_byte(0x40 + 58);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0);
ffs_write_byte(0xfd);

b_temp = ffs_check_command_response_byte(0xff, 0x00);
if (b_temp == 0)
{

b_temp = 0;
break;
}
b_temp = chk_cmd_response_data;
if (b_temp != 0)
{
b_temp = 0;
continue;
}
b_temp = ffs_read_byte();
ffs_read_byte();
ffs_read_byte();
ffs_read_byte();
ffs_read_byte();
}

if (b_temp & 0x40)
{
card_is_high_capacity = 1;
}
else
{
card_is_high_capacity = 0;
}



SSP0CR1 = 0; SSP0CPSR = 4; SSP1CR1 = SSP0CR1_SSE;

init_new_ffs_card_init_mmc_done:

# 469
(1 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));

ffs_write_byte(0xff);

(0 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));




ffs_write_byte(0x40 + 16);
ffs_write_byte(0x00);
ffs_write_byte(0x00);
ffs_write_byte(0x02);
ffs_write_byte(0x00);
ffs_write_byte(0xff);


if (ffs_check_command_response_byte(0xff, 0x00) == 0)
goto init_new_ffs_card_fail;


ffs_bytes_per_sector = 512;


(1 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));
ffs_write_byte(0xff);
(0 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));

# 502
ffs_read_sector_to_buffer(0);


buffer_pointer = &ffs_general_buffer[0];
buffer_pointer += 446;

# 513
buffer_pointer++;


head = *buffer_pointer++;



w_temp = (WORD)*buffer_pointer++;
w_temp |= (WORD)(*buffer_pointer++) << 8;

cylinder_no = (w_temp >> 8);
if (w_temp & 0x0040)
cylinder_no += 0x0100;
if (w_temp & 0x0080)
cylinder_no += 0x0200;

sector = (BYTE)(w_temp & 0x003f);



b_temp = *buffer_pointer++;

if (b_temp == 0x04)
disk_is_fat_32 = 0;
else if (b_temp == 0x06)
disk_is_fat_32 = 0;
else if (b_temp == 0x0b)
disk_is_fat_32 = 1;
else if (b_temp == 0x0c)
disk_is_fat_32 = 1;
else if (b_temp == 0x0e)
disk_is_fat_32 = 0;
else
goto init_new_ffs_card_fail;


buffer_pointer++;


buffer_pointer++;
buffer_pointer++;



main_partition_start_sector = (DWORD)*buffer_pointer++;
main_partition_start_sector |= (DWORD)(*buffer_pointer++) << 8;
main_partition_start_sector |= (DWORD)(*buffer_pointer++) << 16;
main_partition_start_sector |= (DWORD)(*buffer_pointer++) << 24;



ffs_no_of_partition_sectors = (DWORD)*buffer_pointer++;
ffs_no_of_partition_sectors |= (DWORD)(*buffer_pointer++) << 8;
ffs_no_of_partition_sectors |= (DWORD)(*buffer_pointer++) << 16;
ffs_no_of_partition_sectors |= (DWORD)(*buffer_pointer++) << 24;

# 575
lba = main_partition_start_sector;

ffs_read_sector_to_buffer(lba);
buffer_pointer = &ffs_general_buffer[0];


buffer_pointer += 11;



ffs_bytes_per_sector = (WORD)*buffer_pointer++;
ffs_bytes_per_sector |= (WORD)(*buffer_pointer++) << 8;
if (ffs_bytes_per_sector != 512)
goto init_new_ffs_card_fail;



sectors_per_cluster = *buffer_pointer++;

b_temp = 0;
for (w_temp = 0x01; w_temp < 0x0100; w_temp <<= 1)
{
if (sectors_per_cluster & (BYTE)w_temp)
b_temp++;
}
if (b_temp != 1)
goto init_new_ffs_card_fail;



number_of_reserved_sectors = (WORD)*buffer_pointer++;
number_of_reserved_sectors |= (WORD)(*buffer_pointer++) << 8;



number_of_copies_of_fat = *buffer_pointer++;
if ((number_of_copies_of_fat > 4) || (number_of_copies_of_fat == 0))
goto init_new_ffs_card_fail;



dw_temp = (DWORD)*buffer_pointer++;
dw_temp |= (DWORD)(*buffer_pointer++) << 8;
number_of_root_directory_sectors = ((dw_temp * 32) + (DWORD)(ffs_bytes_per_sector - 1)) / ffs_bytes_per_sector;



buffer_pointer++;
buffer_pointer++;



if (*buffer_pointer++ != 0xf8)
goto init_new_ffs_card_fail;



sectors_per_fat = (DWORD)*buffer_pointer++;
sectors_per_fat |= (DWORD)(*buffer_pointer++) << 8;


if(disk_is_fat_32 == 0)
{

# 643
fat1_start_sector = main_partition_start_sector + (DWORD)number_of_reserved_sectors;
root_directory_start_sector_cluster = main_partition_start_sector + (DWORD)number_of_reserved_sectors + (sectors_per_fat * number_of_copies_of_fat);
data_area_start_sector = main_partition_start_sector + (DWORD)number_of_reserved_sectors + (sectors_per_fat * number_of_copies_of_fat) + number_of_root_directory_sectors;


active_fat_table_flags = 0;
for (b_temp = 0; b_temp < number_of_copies_of_fat; b_temp++)
{
active_fat_table_flags <<= 1;
active_fat_table_flags++;
}


file_system_information_sector = 0xffff;

}
else
{

# 666
buffer_pointer += 12;


sectors_per_fat = (DWORD)*buffer_pointer++;
sectors_per_fat |= (DWORD)(*buffer_pointer++) << 8;
sectors_per_fat |= (DWORD)(*buffer_pointer++) << 16;
sectors_per_fat |= (DWORD)(*buffer_pointer++) << 24;

# 678
w_temp = (DWORD)*buffer_pointer++;
w_temp |= (DWORD)(*buffer_pointer++) << 8;
if (w_temp & 0x0080)
{


if ((w_temp & 0x000f) > number_of_copies_of_fat)
goto init_new_ffs_card_fail;

switch (w_temp & 0x000f)
{
case 0:
active_fat_table_flags = 0x01;
break;
case 1:
active_fat_table_flags = 0x02;
break;
case 2:
active_fat_table_flags = 0x04;
break;
case 3:
active_fat_table_flags = 0x08;
break;
}
}
else
{

active_fat_table_flags = 0;
for (b_temp = 0; b_temp < number_of_copies_of_fat; b_temp++)
{
active_fat_table_flags <<= 1;
active_fat_table_flags++;
}
}



buffer_pointer++;
buffer_pointer++;



root_directory_start_sector_cluster = (DWORD)*buffer_pointer++;
root_directory_start_sector_cluster |= (DWORD)(*buffer_pointer++) << 8;
root_directory_start_sector_cluster |= (DWORD)(*buffer_pointer++) << 16;
root_directory_start_sector_cluster |= (DWORD)(*buffer_pointer++) << 24;



file_system_information_sector = (DWORD)*buffer_pointer++;
file_system_information_sector |= (DWORD)(*buffer_pointer++) << 8;


fat1_start_sector = main_partition_start_sector + (DWORD)number_of_reserved_sectors;

data_area_start_sector = main_partition_start_sector + (DWORD)number_of_reserved_sectors + (sectors_per_fat * number_of_copies_of_fat);


number_of_root_directory_sectors = 0;
}

# 769
ffs_card_write_protected = 0;

# 778
(1 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));
ffs_card_ok = 1;


last_found_free_cluster = 0;


return;




init_new_ffs_card_fail:
(1 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));
ffs_card_ok = 0;
return;

}

# 829
BYTE ffs_is_card_present (void)
{

# 844
if (FIO0PIN & 0x00080000)
return(0);
else
return(1);

}

# 861
void ffs_read_sector_to_buffer (DWORD sector_lba)
{
WORD count;
BYTE *buffer_pointer;
BYTE read_successful = 0;


if (ffs_buffer_contains_lba == sector_lba)
{
return;
}

(0 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));


__asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop");
ffs_read_byte();
while ((FIO0PIN & 0x00020000) == 0)
ffs_read_byte();


if (ffs_buffer_needs_writing_to_card)
{
if (ffs_buffer_contains_lba != 0xffffffff)
ffs_write_sector_from_buffer(ffs_buffer_contains_lba);

(0 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));

ffs_buffer_needs_writing_to_card = 0;
}

ffs_10ms_timer = 20;
while ((read_successful == 0) && (ffs_10ms_timer))
{
(0 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));
__asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop");


__asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop");
ffs_read_byte();
while ((FIO0PIN & 0x00020000) == 0)
ffs_read_byte();




ffs_write_byte(0x40 + 17);
if (card_is_high_capacity)
{

ffs_write_byte((BYTE)((sector_lba & 0xff000000) >> 24));
ffs_write_byte((BYTE)((sector_lba & 0x00ff0000) >> 16));
ffs_write_byte((BYTE)((sector_lba & 0x0000ff00) >> 8));
ffs_write_byte((BYTE)(sector_lba & 0x000000ff));
}
else
{

ffs_write_byte((BYTE)((sector_lba & 0x007f8000) >> 15));
ffs_write_byte((BYTE)((sector_lba & 0x00007f80) >> 7));
ffs_write_byte((BYTE)((sector_lba & 0x0000007f) << 1));
ffs_write_byte(0x00);
}
ffs_write_byte(0xff);


if (ffs_check_command_response_byte(0xff, 0x00) == 0)
goto ffs_read_sector_to_buffer_exit;


for (count = 1000; count > 0; count--)
{
if (ffs_check_command_response_byte(0xff, 0xfe))
break;

if (count == 1)
goto ffs_read_sector_to_buffer_exit;
}

read_successful = 1;

# 946
buffer_pointer = &ffs_general_buffer[0];

for (count = 0; count < ffs_bytes_per_sector; count++)
{
*buffer_pointer++ = ffs_read_byte();
}

ffs_buffer_contains_lba = sector_lba;


ffs_read_byte();
ffs_read_byte();



ffs_read_sector_to_buffer_exit:
(1 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));


ffs_write_byte(0xff);

}

}

# 981
void ffs_write_sector_from_buffer (DWORD sector_lba)
{
WORD count;
BYTE *buffer_pointer;
BYTE write_successful = 0;



ffs_buffer_needs_writing_to_card = 0;


ffs_10ms_timer = 20;
while ((write_successful == 0) && (ffs_10ms_timer))
{


(0 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));


__asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop"); __asm("nop");
ffs_read_byte();
while ((FIO0PIN & 0x00020000) == 0)
ffs_read_byte();


if (ffs_card_write_protected == 0)
{

ffs_write_byte(0x40 + 24);
if (card_is_high_capacity)
{

ffs_write_byte((BYTE)((sector_lba & 0xff000000) >> 24));
ffs_write_byte((BYTE)((sector_lba & 0x00ff0000) >> 16));
ffs_write_byte((BYTE)((sector_lba & 0x0000ff00) >> 8));
ffs_write_byte((BYTE)(sector_lba & 0x000000ff));
}
else
{

ffs_write_byte((BYTE)((sector_lba & 0x007f8000) >> 15));
ffs_write_byte((BYTE)((sector_lba & 0x00007f80) >> 7));
ffs_write_byte((BYTE)((sector_lba & 0x0000007f) << 1));
ffs_write_byte(0x00);
}
ffs_write_byte(0xff);


if (ffs_check_command_response_byte(0xff, 0x00) == 0)
goto ffs_write_sector_from_buffer_exit;


ffs_write_byte(0xfe);



buffer_pointer = &ffs_general_buffer[0];
for (count = 0; count < ffs_bytes_per_sector; count++)
{
ffs_write_byte(*buffer_pointer++);
}


ffs_write_byte(0xff);
ffs_write_byte(0xff);


if (ffs_check_command_response_byte(0x0f, 0x05) == 0)
goto ffs_write_sector_from_buffer_exit;
else
write_successful = 1;
}


ffs_write_sector_from_buffer_exit:
(1 ? (FIO0SET = 0x40000000) : (FIO0CLR = 0x40000000));

if (write_successful == 0)
{

count = 1000;
while (count)
count--;
}




}
}

# 1085
BYTE ffs_write_byte (BYTE data)
{
BYTE data_rx;


while (SSP0SR & SSP0SR_RNE) spi_rx_dummy_reg = SSP0DR; SSP0DR = data;


while (!(SSP0SR & SSP0SR_RNE))
;


data_rx = (BYTE)SSP0DR;

return (1);

}

# 1113
WORD ffs_read_word (void)
{
WORD data;

data = (WORD)ffs_read_byte();
data += ((WORD)ffs_read_byte() << 8);

return (data);
}

# 1133
BYTE ffs_read_byte (void)
{

while (SSP0SR & SSP0SR_RNE) spi_rx_dummy_reg = SSP0DR; SSP0DR = 0xff;


while (!(SSP0SR & SSP0SR_RNE))
;

return((BYTE)SSP0DR);

}

# 1152
BYTE ffs_check_command_response_byte (BYTE mask, BYTE data_requried)
{
BYTE count;


for (count = 0; count < 9; count++)
{

while (SSP0SR & SSP0SR_RNE) spi_rx_dummy_reg = SSP0DR; SSP0DR = 0xff;


while (!(SSP0SR & SSP0SR_RNE))
;

chk_cmd_response_data = (BYTE)SSP0DR;

if ((chk_cmd_response_data & mask) == (data_requried & mask))
return(1);
}


return(0);

}

