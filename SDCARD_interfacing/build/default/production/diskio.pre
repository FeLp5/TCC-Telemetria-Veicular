
# 1 "diskio.c"

# 58 "ff.h"
typedef unsigned int UINT;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef WORD WCHAR;

# 82
typedef DWORD FSIZE_t;
typedef DWORD LBA_t;

# 105
typedef char TCHAR;

# 132
typedef struct {
BYTE fs_type;
BYTE pdrv;
BYTE n_fats;
BYTE wflag;
BYTE fsi_flag;
WORD id;
WORD n_rootdir;
WORD csize;

# 154
DWORD last_clst;
DWORD free_clst;

# 165
DWORD n_fatent;
DWORD fsize;
LBA_t volbase;
LBA_t fatbase;
LBA_t dirbase;
LBA_t database;

# 174
LBA_t winsect;
BYTE win[512];
} FATFS;

# 182
typedef struct {
FATFS* fs;
WORD id;
BYTE attr;
BYTE stat;
DWORD sclust;
FSIZE_t objsize;

# 199
} FFOBJID;

# 205
typedef struct {
FFOBJID obj;
BYTE flag;
BYTE err;
FSIZE_t fptr;
DWORD clust;
LBA_t sect;

LBA_t dir_sect;
BYTE* dir_ptr;

# 220
BYTE buf[512];

} FIL;

# 228
typedef struct{
FFOBJID obj;
DWORD dptr;
DWORD clust;
LBA_t sect;
BYTE* dir;
BYTE fn[12];

# 241
} DIR;

# 247
typedef struct {
FSIZE_t fsize;
WORD fdate;
WORD ftime;
BYTE fattrib;




TCHAR fname[12 + 1];

} FILINFO;

# 264
typedef struct {
BYTE fmt;
BYTE n_fat;
UINT align;
UINT n_root;
DWORD au_size;
} MKFS_PARM;

# 276
typedef enum {
FR_OK = 0,
FR_DISK_ERR,
FR_INT_ERR,
FR_NOT_READY,
FR_NO_FILE,
FR_NO_PATH,
FR_INVALID_NAME,
FR_DENIED,
FR_EXIST,
FR_INVALID_OBJECT,
FR_WRITE_PROTECTED,
FR_INVALID_DRIVE,
FR_NOT_ENABLED,
FR_NO_FILESYSTEM,
FR_MKFS_ABORTED,
FR_TIMEOUT,
FR_LOCKED,
FR_NOT_ENOUGH_CORE,
FR_TOO_MANY_OPEN_FILES,
FR_INVALID_PARAMETER
} FRESULT;

# 304
FRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);
FRESULT f_close (FIL* fp);
FRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);
FRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);
FRESULT f_lseek (FIL* fp, FSIZE_t ofs);
FRESULT f_truncate (FIL* fp);
FRESULT f_sync (FIL* fp);
FRESULT f_opendir (DIR* dp, const TCHAR* path);
FRESULT f_closedir (DIR* dp);
FRESULT f_readdir (DIR* dp, FILINFO* fno);
FRESULT f_findfirst (DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);
FRESULT f_findnext (DIR* dp, FILINFO* fno);
FRESULT f_mkdir (const TCHAR* path);
FRESULT f_unlink (const TCHAR* path);
FRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);
FRESULT f_stat (const TCHAR* path, FILINFO* fno);
FRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);
FRESULT f_utime (const TCHAR* path, const FILINFO* fno);
FRESULT f_chdir (const TCHAR* path);
FRESULT f_chdrive (const TCHAR* path);
FRESULT f_getcwd (TCHAR* buff, UINT len);
FRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);
FRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);
FRESULT f_setlabel (const TCHAR* label);
FRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);
FRESULT f_expand (FIL* fp, FSIZE_t fsz, BYTE opt);
FRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);
FRESULT f_mkfs (const TCHAR* path, const MKFS_PARM* opt, void* work, UINT len);
FRESULT f_fdisk (BYTE pdrv, const LBA_t ptbl[], void* work);
FRESULT f_setcp (WORD cp);
int f_putc (TCHAR c, FIL* fp);
int f_puts (const TCHAR* str, FIL* cp);
int f_printf (FIL* fp, const TCHAR* str, ...);
TCHAR* f_gets (TCHAR* buff, int len, FIL* fp);

# 356
DWORD get_fattime (void);

# 13 "diskio.h"
typedef BYTE DSTATUS;


typedef enum {
RES_OK = 0,
RES_ERROR,
RES_WRPRT,
RES_NOTRDY,
RES_PARERR
} DRESULT;

# 29
DSTATUS disk_initialize (BYTE pdrv);
DSTATUS disk_status (BYTE pdrv);
DRESULT disk_read (BYTE pdrv, BYTE* buff, LBA_t sector, UINT count);
DRESULT disk_write (BYTE pdrv, const BYTE* buff, LBA_t sector, UINT count);
DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);

# 23 "diskio.c"
DSTATUS disk_status (
BYTE pdrv
)
{
DSTATUS stat;
int result;

switch (pdrv) {
case 0 :
result = RAM_disk_status();



return stat;

case 1 :
result = MMC_disk_status();



return stat;

case 2 :
result = USB_disk_status();



return stat;
}
return 0x01;
}

# 61
DSTATUS disk_initialize (
BYTE pdrv
)
{
DSTATUS stat;
int result;

switch (pdrv) {
case 0 :
result = RAM_disk_initialize();



return stat;

case 1 :
result = MMC_disk_initialize();



return stat;

case 2 :
result = USB_disk_initialize();



return stat;
}
return 0x01;
}

# 99
DRESULT disk_read (
BYTE pdrv,
BYTE *buff,
LBA_t sector,
UINT count
)
{
DRESULT res;
int result;

switch (pdrv) {
case 0 :


result = RAM_disk_read(buff, sector, count);



return res;

case 1 :


result = MMC_disk_read(buff, sector, count);



return res;

case 2 :


result = USB_disk_read(buff, sector, count);



return res;
}

return RES_PARERR;
}

# 149
DRESULT disk_write (
BYTE pdrv,
const BYTE *buff,
LBA_t sector,
UINT count
)
{
DRESULT res;
int result;

switch (pdrv) {
case 0 :


result = RAM_disk_write(buff, sector, count);



return res;

case 1 :


result = MMC_disk_write(buff, sector, count);



return res;

case 2 :


result = USB_disk_write(buff, sector, count);



return res;
}

return RES_PARERR;
}

# 198
DRESULT disk_ioctl (
BYTE pdrv,
BYTE cmd,
void *buff
)
{
DRESULT res;
int result;

switch (pdrv) {
case 0 :



return res;

case 1 :



return res;

case 2 :



return res;
}

return RES_PARERR;
}

