
# 1 "bibliotecas/tff.c"

# 4 "C:\Program Files (x86)\Microchip\xc8\v1.45\include\__size_t.h"
typedef unsigned size_t;

# 14 "C:\Program Files (x86)\Microchip\xc8\v1.45\include\string.h"
extern void * memcpy(void *, const void *, size_t);
extern void * memmove(void *, const void *, size_t);
extern void * memset(void *, int, size_t);

# 36
extern char * strcat(char *, const char *);
extern char * strcpy(char *, const char *);
extern char * strncat(char *, const char *, size_t);
extern char * strncpy(char *, const char *, size_t);
extern char * strdup(const char *);
extern char * strtok(char *, const char *);


extern int memcmp(const void *, const void *, size_t);
extern int strcmp(const char *, const char *);
extern int stricmp(const char *, const char *);
extern int strncmp(const char *, const char *, size_t);
extern int strnicmp(const char *, const char *, size_t);
extern void * memchr(const void *, int, size_t);
extern size_t strcspn(const char *, const char *);
extern char * strpbrk(const char *, const char *);
extern size_t strspn(const char *, const char *);
extern char * strstr(const char *, const char *);
extern char * stristr(const char *, const char *);
extern char * strerror(int);
extern size_t strlen(const char *);
extern char * strchr(const char *, int);
extern char * strichr(const char *, int);
extern char * strrchr(const char *, int);
extern char * strrichr(const char *, int);

# 8 "bibliotecas/integer.h"
typedef struct{
unsigned int hora;
unsigned int min;
unsigned int seg;
unsigned char dia;
unsigned char mes;
unsigned char ano;
}fat_time;

typedef int INT;
typedef unsigned int UINT;


typedef signed char CHAR;
typedef unsigned char UCHAR;
typedef unsigned char BYTE;


typedef short SHORT;
typedef unsigned short USHORT;
typedef unsigned short WORD;


typedef long LONG;
typedef unsigned long ULONG;
typedef unsigned long DWORD;


typedef enum { FALSE = 0, TRUE } BOOL;

# 65 "bibliotecas/tff.h"
typedef DWORD CLUST;

# 74
typedef struct _FATFS {
WORD id;
WORD n_rootdir;
DWORD winsect;
DWORD fatbase;
DWORD dirbase;
DWORD database;
CLUST sects_fat;
CLUST max_clust;

CLUST last_clust;
CLUST free_clust;

# 92
BYTE fs_type;
BYTE csize;
BYTE n_fats;
BYTE winflag;
BYTE win[512];
} FATFS;



typedef struct _DIR_E {
WORD id;
WORD index;
FATFS* fs;
CLUST sclust;
CLUST clust;
DWORD sect;
} DIR_E;



typedef struct _FIL {
WORD id;
BYTE flag;
BYTE csect;
FATFS* fs;
DWORD fptr;
DWORD fsize;
CLUST org_clust;
CLUST curr_clust;
DWORD curr_sect;

DWORD dir_sect;
BYTE* dir_ptr;

} FIL;



typedef struct _FILINFO {
DWORD fsize;
WORD fdate;
WORD ftime;
BYTE fattrib;
char fname[8+1+3+1];
} FILINFO;




typedef enum {
FR_OK = 0,
FR_NOT_READY,
FR_NO_FILE,
FR_NO_PATH,
FR_INVALID_NAME,
FR_INVALID_DRIVE,
FR_DENIED,
FR_EXIST,
FR_RW_ERROR,
FR_WRITE_PROTECTED,
FR_NOT_ENABLED,
FR_NO_FILESYSTEM,
FR_INVALID_OBJECT,
FR_MKFS_ABORTED
} FRESULT;

# 163
FRESULT f_mount (BYTE, FATFS*);
FRESULT f_open (FIL*, const char*, BYTE);
FRESULT f_read (FIL*, void*, UINT, UINT*);
FRESULT f_write (FIL*, const void*, UINT, UINT*);
FRESULT f_lseek (FIL*, DWORD);
FRESULT f_close (FIL*);
FRESULT f_opendir (DIR_E*, const char*);
FRESULT f_readdir (DIR_E*, FILINFO*);
FRESULT f_stat (const char*, FILINFO*);
FRESULT f_getfree (const char*, DWORD*, FATFS**);
FRESULT f_truncate (FIL*);
FRESULT f_sync (FIL*);
FRESULT f_unlink (const char*);
FRESULT f_mkdir (const char*);
FRESULT f_chmod (const char*, BYTE, BYTE);
FRESULT f_utime (const char*, const FILINFO*);
FRESULT f_rename (const char*, const char*);
FRESULT f_forward (FIL*, UINT(*)(const BYTE*,UINT), UINT, UINT*);



int fputc (int, FIL*);
int fputs (const char*, FIL*);
int fprintf (FIL*, const char*, ...);
char* fgets (char*, int, FIL*);

# 193
DWORD get_fattime (void);

# 26 "bibliotecas/diskio.h"
typedef BYTE DSTATUS;


typedef enum {
RES_OK = 0,
RES_ERROR,
RES_WRPRT,
RES_NOTRDY,
RES_PARERR
} DRESULT;

# 42
DSTATUS disk_initialize (BYTE pdrv);
DSTATUS disk_status (BYTE pdrv);
DRESULT disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);
DRESULT disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);
DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);

# 58 "bibliotecas/tff.c"
static
FATFS *FatFs;
static
WORD fsid;

# 75
static
BOOL move_window (
DWORD sector
)
{
DWORD wsect;
FATFS *fs = FatFs;


wsect = fs->winsect;
if (wsect != sector) {

BYTE n;
if (fs->winflag) {
if (disk_write(0, fs->win, wsect, 1) != RES_OK)
return FALSE;
fs->winflag = 0;
if (wsect < (fs->fatbase + fs->sects_fat)) {
for (n = fs->n_fats; n >= 2; n--) {
wsect += fs->sects_fat;
disk_write(0, fs->win, wsect, 1);
}
}
}

if (sector) {
if (disk_read(0, fs->win, sector, 1) != RES_OK)
return FALSE;
fs->winsect = sector;
}
}
return TRUE;
}

# 117
static
FRESULT sync (void)
{
FATFS *fs = FatFs;


fs->winflag = 1;
if (!move_window(0)) return FR_RW_ERROR;

# 140
if (disk_ioctl(0, 0, (0)) != RES_OK)
return FR_RW_ERROR;
return FR_OK;
}

# 153
static
CLUST get_cluster (
CLUST clust
)
{
WORD wc, bc;
DWORD fatsect;
FATFS *fs = FatFs;


if (clust >= 2 && clust < fs->max_clust) {
fatsect = fs->fatbase;
switch (fs->fs_type) {
case 1 :
bc = (WORD)clust * 3 / 2;
if (!move_window(fatsect + bc / 512U)) break;
wc = fs->win[bc % 512U]; bc++;
if (!move_window(fatsect + bc / 512U)) break;
wc |= (WORD)fs->win[bc % 512U] << 8;
return (clust & 1) ? (wc >> 4) : (wc & 0xFFF);

case 2 :
if (!move_window(fatsect + clust / 256)) break;
return (WORD)(((WORD)*(volatile BYTE*)((&fs->win[((WORD)clust * 2) % 512U])+1)<<8)|(WORD)*(volatile BYTE*)(&fs->win[((WORD)clust * 2) % 512U]));

case 3 :
if (!move_window(fatsect + clust / 128)) break;
return (DWORD)(((DWORD)*(volatile BYTE*)((&fs->win[((WORD)clust * 4) % 512U])+3)<<24)|((DWORD)*(volatile BYTE*)((&fs->win[((WORD)clust * 4) % 512U])+2)<<16)|((WORD)*(volatile BYTE*)((&fs->win[((WORD)clust * 4) % 512U])+1)<<8)|*(volatile BYTE*)(&fs->win[((WORD)clust * 4) % 512U])) & 0x0FFFFFFF;

}
}

return 1;
}

# 196
static
BOOL put_cluster (
CLUST clust,
CLUST val
)
{
WORD bc;
BYTE *p;
DWORD fatsect;
FATFS *fs = FatFs;


fatsect = fs->fatbase;
switch (fs->fs_type) {
case 1 :
bc = (WORD)clust * 3 / 2;
if (!move_window(fatsect + bc / 512U)) return FALSE;
p = &fs->win[bc % 512U];
*p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
bc++;
fs->winflag = 1;
if (!move_window(fatsect + bc / 512U)) return FALSE;
p = &fs->win[bc % 512U];
*p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
break;

case 2 :
if (!move_window(fatsect + clust / 256)) return FALSE;
*(volatile BYTE*)(&fs->win[((WORD)clust * 2) % 512U])=(BYTE)((WORD)val); *(volatile BYTE*)((&fs->win[((WORD)clust * 2) % 512U])+1)=(BYTE)((WORD)((WORD)val)>>8);
break;

case 3 :
if (!move_window(fatsect + clust / 128)) return FALSE;
*(volatile BYTE*)(&fs->win[((WORD)clust * 4) % 512U])=(BYTE)(val); *(volatile BYTE*)((&fs->win[((WORD)clust * 4) % 512U])+1)=(BYTE)((WORD)(val)>>8); *(volatile BYTE*)((&fs->win[((WORD)clust * 4) % 512U])+2)=(BYTE)((DWORD)(val)>>16); *(volatile BYTE*)((&fs->win[((WORD)clust * 4) % 512U])+3)=(BYTE)((DWORD)(val)>>24);
break;

default :
return FALSE;
}
fs->winflag = 1;
return TRUE;
}

# 248
static
BOOL remove_chain (
CLUST clust
)
{
CLUST nxt;
FATFS *fs = FatFs;


while (clust >= 2 && clust < fs->max_clust) {
nxt = get_cluster(clust);
if (nxt == 1) return FALSE;
if (!put_cluster(clust, 0)) return FALSE;
if (fs->free_clust != (CLUST)0xFFFFFFFF) {
fs->free_clust++;

# 266
}
clust = nxt;
}
return TRUE;
}

# 281
static
CLUST create_chain (
CLUST clust
)
{
CLUST cstat, ncl, scl, mcl;
FATFS *fs = FatFs;


mcl = fs->max_clust;
if (clust == 0) {
scl = fs->last_clust;
if (scl < 2 || scl >= mcl) scl = 1;
}
else {
cstat = get_cluster(clust);
if (cstat < 2) return 1;
if (cstat < mcl) return cstat;
scl = clust;
}

ncl = scl;
for (;;) {
ncl++;
if (ncl >= mcl) {
ncl = 2;
if (ncl > scl) return 0;
}
cstat = get_cluster(ncl);
if (cstat == 0) break;
if (cstat == 1) return 1;
if (ncl == scl) return 0;
}

if (!put_cluster(ncl, (CLUST)0x0FFFFFFF)) return 1;
if (clust != 0 && !put_cluster(clust, ncl)) return 1;

fs->last_clust = ncl;
if (fs->free_clust != (CLUST)0xFFFFFFFF) {
fs->free_clust--;

# 324
}

return ncl;
}

# 337
static
DWORD clust2sect (
CLUST clust
)
{
FATFS *fs = FatFs;


clust -= 2;
if (clust >= (fs->max_clust - 2)) return 0;
return (DWORD)clust * fs->csize + fs->database;
}

# 357
static
BOOL next_dir_entry (
DIR_E *dj
)
{
CLUST clust;
WORD idx;


idx = dj->index + 1;
if ((idx & 15) == 0) {
dj->sect++;
if (dj->clust == 0) {
if (idx >= dj->fs->n_rootdir) return FALSE;
} else {
if (((idx / 16) & (dj->fs->csize - 1)) == 0) {
clust = get_cluster(dj->clust);
if (clust < 2 || clust >= dj->fs->max_clust)
return FALSE;
dj->clust = clust;
dj->sect = clust2sect(clust);
}
}
}
dj->index = idx;
return TRUE;
}

# 393
static
void get_fileinfo (
FILINFO *finfo,
const BYTE *dir
)
{
BYTE n, c, a;
char *p;


p = &finfo->fname[0];
a = 1 ? dir[12] : 0;
for (n = 0; n < 8; n++) {
c = dir[n];
if (c == ' ') break;
if (c == 0x05) c = 0xE5;
if (a & 0x08 && c >= 'A' && c <= 'Z') c += 0x20;
*p++ = c;
}
if (dir[8] != ' ') {
*p++ = '.';
for (n = 8; n < 11; n++) {
c = dir[n];
if (c == ' ') break;
if (a & 0x10 && c >= 'A' && c <= 'Z') c += 0x20;
*p++ = c;
}
}
*p = '\0';

finfo->fattrib = dir[11];
finfo->fsize = (DWORD)(((DWORD)*(volatile BYTE*)((&dir[28])+3)<<24)|((DWORD)*(volatile BYTE*)((&dir[28])+2)<<16)|((WORD)*(volatile BYTE*)((&dir[28])+1)<<8)|*(volatile BYTE*)(&dir[28]));
finfo->fdate = (WORD)(((WORD)*(volatile BYTE*)((&dir[24])+1)<<8)|(WORD)*(volatile BYTE*)(&dir[24]));
finfo->ftime = (WORD)(((WORD)*(volatile BYTE*)((&dir[22])+1)<<8)|(WORD)*(volatile BYTE*)(&dir[22]));
}

# 437
static
char make_dirfile (
const char **path,
char *dirname
)
{
BYTE n, t, c, a, b;


memset(dirname, ' ', 8+3);
a = 0; b = 0x18;
n = 0; t = 8;
for (;;) {
c = *(*path)++;
if (c == '\0' || c == '/') {
if (n == 0) break;
dirname[11] = 1 ? (a & b) : 0;
return c;
}
if (c <= ' ' || c == 0x7F) break;
if (c == '.') {
if (!(a & 1) && n >= 1 && n <= 8) {
n = 8; t = 11; continue;
}
break;
}
if (1 &&
((c >= 0x81 && c <= 0x9F) ||
(c >= 0xE0 && c <= 0xFC))) {
if (n == 0 && c == 0xE5)
c = 0x05;
a ^= 1; goto md_l2;
}
if (c == '"') break;
if (c <= ')') goto md_l1;
if (c <= ',') break;
if (c <= '9') goto md_l1;
if (c <= '?') break;
if (!(a & 1)) {
if (c == '|') break;
if (c >= '[' && c <= ']') break;
if (1 && c >= 'A' && c <= 'Z')
(t == 8) ? (b &= 0xF7) : (b &= 0xEF);
if (c >= 'a' && c <= 'z') {
c -= 0x20;
if (1) (t == 8) ? (a |= 0x08) : (a |= 0x10);
}
}
md_l1:
a &= 0xFE;
md_l2:
if (n >= t) break;
dirname[n++] = c;
}
return 1;
}

# 500
static
FRESULT trace_path (
DIR_E *dj,
char *fn,
const char *path,
BYTE **dir
)
{
CLUST clust;
char ds;
BYTE *dptr = (0);
FATFS *fs = FatFs;


dj->fs = fs;
clust = fs->dirbase;

if (fs->fs_type == 3) {
dj->clust = dj->sclust = clust;
dj->sect = clust2sect(clust);
} else

{
dj->clust = dj->sclust = 0;
dj->sect = clust;
}
dj->index = 0;

if (*path == '\0') {
*dir = (0); return FR_OK;
}

for (;;) {
ds = make_dirfile(&path, fn);
if (ds == 1) return FR_INVALID_NAME;
for (;;) {
if (!move_window(dj->sect)) return FR_RW_ERROR;
dptr = &fs->win[(dj->index & 15) * 32];
if (dptr[0] == 0)
return !ds ? FR_NO_FILE : FR_NO_PATH;
if (dptr[0] != 0xE5
&& !(dptr[11] & 0x08)
&& !memcmp(&dptr[0], fn, 8+3) ) break;
if (!next_dir_entry(dj))
return !ds ? FR_NO_FILE : FR_NO_PATH;
}
if (!ds) { *dir = dptr; return FR_OK; }
if (!(dptr[11] & 0x10)) return FR_NO_PATH;
clust =

((DWORD)(WORD)(((WORD)*(volatile BYTE*)((&dptr[20])+1)<<8)|(WORD)*(volatile BYTE*)(&dptr[20])) << 16) |

(WORD)(((WORD)*(volatile BYTE*)((&dptr[26])+1)<<8)|(WORD)*(volatile BYTE*)(&dptr[26]));
dj->clust = dj->sclust = clust;
dj->sect = clust2sect(clust);
dj->index = 2;
}
}

# 566
static
FRESULT reserve_direntry (
DIR_E *dj,
BYTE **dir
)
{
CLUST clust;
DWORD sector;
BYTE c, n, *dptr;
FATFS *fs = dj->fs;



clust = dj->sclust;
if (clust != 0) {
dj->clust = clust;
dj->sect = clust2sect(clust);
} else {
dj->sect = fs->dirbase;
}
dj->index = 0;

do {
if (!move_window(dj->sect)) return FR_RW_ERROR;
dptr = &fs->win[(dj->index & 15) * 32];
c = dptr[0];
if (c == 0 || c == 0xE5) {
*dir = dptr; return FR_OK;
}
} while (next_dir_entry(dj));



if (clust == 0 || !(clust = create_chain(dj->clust))) return FR_DENIED;
if (clust == 1 || !move_window(0)) return FR_RW_ERROR;

fs->winsect = sector = clust2sect(clust);
memset(fs->win, 0, 512U);
for (n = fs->csize; n; n--) {
if (disk_write(0, fs->win, sector, 1) != RES_OK)
return FR_RW_ERROR;
sector++;
}
fs->winflag = 1;
*dir = fs->win;
return FR_OK;
}

# 622
static
BYTE check_fs (
DWORD sect
)
{
FATFS *fs = FatFs;

if (disk_read(0, fs->win, sect, 1) != RES_OK)
return 2;
if ((WORD)(((WORD)*(volatile BYTE*)((&fs->win[510])+1)<<8)|(WORD)*(volatile BYTE*)(&fs->win[510])) != 0xAA55)
return 2;

if (!memcmp(&fs->win[54], "FAT", 3))
return 0;

if (!memcmp(&fs->win[82], "FAT32", 5) && !(fs->win[40] & 0x80))
return 0;

return 1;
}

# 650
static
FRESULT auto_mount (
const char **path,
BYTE chk_wp
)
{
BYTE fmt;
DSTATUS stat;
DWORD bootsect, fatsize, totalsect, maxclust;
const char *p = *path;
FATFS *fs;


while (*p == ' ') p++;
if (*p == '/') p++;
*path = p;


fs = FatFs;
if (!fs) return FR_NOT_ENABLED;

if (fs->fs_type) {
stat = disk_status(0);
if (!(stat & 0x01)) {

if (chk_wp && (stat & 0x04))
return FR_WRITE_PROTECTED;

return FR_OK;
}
}



memset(fs, 0, sizeof(FATFS));
stat = disk_initialize(0);
if (stat & 0x01)
return FR_NOT_READY;

if (chk_wp && (stat & 0x04))
return FR_WRITE_PROTECTED;



fmt = check_fs(bootsect = 0);
if (fmt == 1) {

if (fs->win[446+4]) {
bootsect = (DWORD)(((DWORD)*(volatile BYTE*)((&fs->win[446+8])+3)<<24)|((DWORD)*(volatile BYTE*)((&fs->win[446+8])+2)<<16)|((WORD)*(volatile BYTE*)((&fs->win[446+8])+1)<<8)|*(volatile BYTE*)(&fs->win[446+8]));
fmt = check_fs(bootsect);
}
}
if (fmt || (WORD)(((WORD)*(volatile BYTE*)((&fs->win[11])+1)<<8)|(WORD)*(volatile BYTE*)(&fs->win[11])) != 512U)
return FR_NO_FILESYSTEM;


fatsize = (WORD)(((WORD)*(volatile BYTE*)((&fs->win[22])+1)<<8)|(WORD)*(volatile BYTE*)(&fs->win[22]));
if (!fatsize) fatsize = (DWORD)(((DWORD)*(volatile BYTE*)((&fs->win[36])+3)<<24)|((DWORD)*(volatile BYTE*)((&fs->win[36])+2)<<16)|((WORD)*(volatile BYTE*)((&fs->win[36])+1)<<8)|*(volatile BYTE*)(&fs->win[36]));
fs->sects_fat = (CLUST)fatsize;
fs->n_fats = fs->win[16];
fatsize *= fs->n_fats;
fs->fatbase = bootsect + (WORD)(((WORD)*(volatile BYTE*)((&fs->win[14])+1)<<8)|(WORD)*(volatile BYTE*)(&fs->win[14]));
fs->csize = fs->win[13];
fs->n_rootdir = (WORD)(((WORD)*(volatile BYTE*)((&fs->win[17])+1)<<8)|(WORD)*(volatile BYTE*)(&fs->win[17]));
totalsect = (WORD)(((WORD)*(volatile BYTE*)((&fs->win[19])+1)<<8)|(WORD)*(volatile BYTE*)(&fs->win[19]));
if (!totalsect) totalsect = (DWORD)(((DWORD)*(volatile BYTE*)((&fs->win[32])+3)<<24)|((DWORD)*(volatile BYTE*)((&fs->win[32])+2)<<16)|((WORD)*(volatile BYTE*)((&fs->win[32])+1)<<8)|*(volatile BYTE*)(&fs->win[32]));
fs->max_clust = maxclust = (totalsect
- (WORD)(((WORD)*(volatile BYTE*)((&fs->win[14])+1)<<8)|(WORD)*(volatile BYTE*)(&fs->win[14])) - fatsize - fs->n_rootdir / 16
) / fs->csize + 2;

fmt = 1;
if (maxclust >= 0xFF7) fmt = 2;
if (maxclust >= 0xFFF7)



fmt = 3;
if (fmt == 3)
fs->dirbase = (DWORD)(((DWORD)*(volatile BYTE*)((&fs->win[44])+3)<<24)|((DWORD)*(volatile BYTE*)((&fs->win[44])+2)<<16)|((WORD)*(volatile BYTE*)((&fs->win[44])+1)<<8)|*(volatile BYTE*)(&fs->win[44]));
else

fs->dirbase = fs->fatbase + fatsize;
fs->database = fs->fatbase + fatsize + fs->n_rootdir / 16;



fs->free_clust = (CLUST)0xFFFFFFFF;

# 752
fs->fs_type = fmt;
fs->id = ++fsid;
return FR_OK;
}

# 764
static
FRESULT validate (
const FATFS *fs,
WORD id
)
{
if (!fs || !fs->fs_type || fs->id != id)
return FR_INVALID_OBJECT;
if (disk_status(0) & 0x01)
return FR_NOT_READY;

return FR_OK;
}

# 792
FRESULT f_mount (
BYTE drv,
FATFS *fs
)
{
if (drv) return FR_INVALID_DRIVE;

if (FatFs) FatFs->fs_type = 0;

FatFs = fs;
if (fs) fs->fs_type = 0;

return FR_OK;
}


DWORD get_fattime(void)
{
fat_time f_time;

return (DWORD)(f_time.ano ) << 25 |
(DWORD)(f_time.mes) << 21 |
(DWORD)(f_time.mes) << 16 |
(DWORD)(f_time.hora) << 11 |
(DWORD)(f_time.min) << 5 |
(DWORD)(f_time.seg) >> 1;
}

# 824
FRESULT f_open (
FIL *fp,
const char *path,
BYTE mode
)
{
FRESULT res;
DIR_E dj;
BYTE *dir;
char fn[8+3+1];


fp->fs = (0);

mode &= (0x01|0x02|0x08|0x10|0x04);
res = auto_mount(&path, (BYTE)(mode & (0x02|0x08|0x10|0x04)));

# 844
if (res != FR_OK) return res;
res = trace_path(&dj, fn, path, &dir);



if (mode & (0x08|0x10|0x04)) {
CLUST rs;
DWORD dw;
if (res != FR_OK) {
if (res != FR_NO_FILE) return res;
res = reserve_direntry(&dj, &dir);
if (res != FR_OK) return res;
memset(dir, 0, 32);
memcpy(&dir[0], fn, 8+3);
dir[12] = fn[11];
mode |= 0x08;
}
else {
if (mode & 0x04)
return FR_EXIST;
if (!dir || (dir[11] & (0x01|0x10)))
return FR_DENIED;
if (mode & 0x08) {

rs = ((DWORD)(WORD)(((WORD)*(volatile BYTE*)((&dir[20])+1)<<8)|(WORD)*(volatile BYTE*)(&dir[20])) << 16) | (WORD)(((WORD)*(volatile BYTE*)((&dir[26])+1)<<8)|(WORD)*(volatile BYTE*)(&dir[26]));
*(volatile BYTE*)(&dir[20])=(BYTE)(0); *(volatile BYTE*)((&dir[20])+1)=(BYTE)((WORD)(0)>>8);

# 873
*(volatile BYTE*)(&dir[26])=(BYTE)(0); *(volatile BYTE*)((&dir[26])+1)=(BYTE)((WORD)(0)>>8);
*(volatile BYTE*)(&dir[28])=(BYTE)(0); *(volatile BYTE*)((&dir[28])+1)=(BYTE)((WORD)(0)>>8); *(volatile BYTE*)((&dir[28])+2)=(BYTE)((DWORD)(0)>>16); *(volatile BYTE*)((&dir[28])+3)=(BYTE)((DWORD)(0)>>24);
dj.fs->winflag = 1;
dw = dj.fs->winsect;
if (!remove_chain(rs) || !move_window(dw))
return FR_RW_ERROR;
dj.fs->last_clust = rs - 1;
}
}
if (mode & 0x08) {
dir[11] = 0;
dw = get_fattime();
*(volatile BYTE*)(&dir[14])=(BYTE)(dw); *(volatile BYTE*)((&dir[14])+1)=(BYTE)((WORD)(dw)>>8); *(volatile BYTE*)((&dir[14])+2)=(BYTE)((DWORD)(dw)>>16); *(volatile BYTE*)((&dir[14])+3)=(BYTE)((DWORD)(dw)>>24);
dj.fs->winflag = 1;
mode |= 0x20;
}
}

else {

if (res != FR_OK) return res;
if (!dir || (dir[11] & 0x10))
return FR_NO_FILE;

if ((mode & 0x02) && (dir[11] & 0x01))
return FR_DENIED;
}
fp->dir_sect = dj.fs->winsect;
fp->dir_ptr = dir;

fp->flag = mode;
fp->org_clust =

((DWORD)(WORD)(((WORD)*(volatile BYTE*)((&dir[20])+1)<<8)|(WORD)*(volatile BYTE*)(&dir[20])) << 16) |

(WORD)(((WORD)*(volatile BYTE*)((&dir[26])+1)<<8)|(WORD)*(volatile BYTE*)(&dir[26]));
fp->fsize = (DWORD)(((DWORD)*(volatile BYTE*)((&dir[28])+3)<<24)|((DWORD)*(volatile BYTE*)((&dir[28])+2)<<16)|((WORD)*(volatile BYTE*)((&dir[28])+1)<<8)|*(volatile BYTE*)(&dir[28]));
fp->fptr = 0; fp->csect = 255;
fp->fs = dj.fs; fp->id = dj.fs->id;

return FR_OK;
}

# 923
FRESULT f_read (
FIL *fp,
void *buff,
UINT btr,
UINT *br
)
{
FRESULT res;
DWORD sect, remain;
UINT rcnt, cc;
CLUST clust;
BYTE *rbuff = buff;


*br = 0;
res = validate(fp->fs, fp->id);
if (res != FR_OK) return res;
if (fp->flag & 0x80) return FR_RW_ERROR;
if (!(fp->flag & 0x01)) return FR_DENIED;
remain = fp->fsize - fp->fptr;
if (btr > remain) btr = (UINT)remain;

for ( ; btr;
rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
if ((fp->fptr % 512U) == 0) {
if (fp->csect >= fp->fs->csize) {
clust = (fp->fptr == 0) ?
fp->org_clust : get_cluster(fp->curr_clust);
if (clust < 2 || clust >= fp->fs->max_clust) goto fr_error;
fp->curr_clust = clust;
fp->csect = 0;
}
sect = clust2sect(fp->curr_clust) + fp->csect;
cc = btr / 512U;
if (cc) {
if (fp->csect + cc > fp->fs->csize)
cc = fp->fs->csize - fp->csect;
if (disk_read(0, rbuff, sect, (BYTE)cc) != RES_OK)
goto fr_error;
fp->csect += (BYTE)cc;
rcnt = 512U * cc;
continue;
}
fp->csect++;
}
sect = clust2sect(fp->curr_clust) + fp->csect - 1;
if (!move_window(sect)) goto fr_error;
rcnt = 512U - (fp->fptr % 512U);
if (rcnt > btr) rcnt = btr;
memcpy(rbuff, &fp->fs->win[fp->fptr % 512U], rcnt);
}

return FR_OK;

fr_error:
fp->flag |= 0x80;
return FR_RW_ERROR;
}

# 990
FRESULT f_write (
FIL *fp,
const void *buff,
UINT btw,
UINT *bw
)
{
FRESULT res;
DWORD sect;
UINT wcnt, cc;
CLUST clust;
const BYTE *wbuff = buff;


*bw = 0;
res = validate(fp->fs, fp->id);
if (res != FR_OK) return res;
if (fp->flag & 0x80) return FR_RW_ERROR;
if (!(fp->flag & 0x02)) return FR_DENIED;
if (fp->fsize + btw < fp->fsize) return FR_OK;

for ( ; btw;
wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
if ((fp->fptr % 512U) == 0) {
if (fp->csect >= fp->fs->csize) {
if (fp->fptr == 0) {
clust = fp->org_clust;
if (clust == 0)
fp->org_clust = clust = create_chain(0);
} else {
clust = create_chain(fp->curr_clust);
}
if (clust == 0) break;
if (clust == 1 || clust >= fp->fs->max_clust) goto fw_error;
fp->curr_clust = clust;
fp->csect = 0;
}
sect = clust2sect(fp->curr_clust) + fp->csect;
cc = btw / 512U;
if (cc) {
if (fp->csect + cc > fp->fs->csize)
cc = fp->fs->csize - fp->csect;
if (disk_write(0, wbuff, sect, (BYTE)cc) != RES_OK)
goto fw_error;
fp->csect += (BYTE)cc;
wcnt = 512U * cc;
continue;
}
if (fp->fptr >= fp->fsize) {
if (!move_window(0)) goto fw_error;
fp->fs->winsect = sect;
}
fp->csect++;
}
sect = clust2sect(fp->curr_clust) + fp->csect - 1;
if (!move_window(sect)) goto fw_error;
wcnt = 512U - (fp->fptr % 512U);
if (wcnt > btw) wcnt = btw;
memcpy(&fp->fs->win[fp->fptr % 512U], wbuff, wcnt);
fp->fs->winflag = 1;
}

if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;
fp->flag |= 0x20;
return res;

fw_error:
fp->flag |= 0x80;
return FR_RW_ERROR;
}

# 1068
FRESULT f_sync (
FIL *fp
)
{
FRESULT res;
DWORD tim;
BYTE *dir;


res = validate(fp->fs, fp->id);
if (res == FR_OK) {
if (fp->flag & 0x20) {

if (!move_window(fp->dir_sect))
return FR_RW_ERROR;
dir = fp->dir_ptr;
dir[11] |= 0x20;
*(volatile BYTE*)(&dir[28])=(BYTE)(fp->fsize); *(volatile BYTE*)((&dir[28])+1)=(BYTE)((WORD)(fp->fsize)>>8); *(volatile BYTE*)((&dir[28])+2)=(BYTE)((DWORD)(fp->fsize)>>16); *(volatile BYTE*)((&dir[28])+3)=(BYTE)((DWORD)(fp->fsize)>>24);
*(volatile BYTE*)(&dir[26])=(BYTE)(fp->org_clust); *(volatile BYTE*)((&dir[26])+1)=(BYTE)((WORD)(fp->org_clust)>>8);

*(volatile BYTE*)(&dir[20])=(BYTE)(fp->org_clust >> 16); *(volatile BYTE*)((&dir[20])+1)=(BYTE)((WORD)(fp->org_clust >> 16)>>8);

tim = get_fattime();
*(volatile BYTE*)(&dir[22])=(BYTE)(tim); *(volatile BYTE*)((&dir[22])+1)=(BYTE)((WORD)(tim)>>8); *(volatile BYTE*)((&dir[22])+2)=(BYTE)((DWORD)(tim)>>16); *(volatile BYTE*)((&dir[22])+3)=(BYTE)((DWORD)(tim)>>24);
fp->flag &= (BYTE)~0x20;
res = sync();
}
}
return res;
}

# 1107
FRESULT f_close (
FIL *fp
)
{
FRESULT res;



res = f_sync(fp);

# 1119
if (res == FR_OK) fp->fs = (0);
return res;
}

# 1131
FRESULT f_lseek (
FIL *fp,
DWORD ofs
)
{
FRESULT res;
CLUST clust;
DWORD csize, ifptr;


res = validate(fp->fs, fp->id);
if (res != FR_OK) return res;
if (fp->flag & 0x80) return FR_RW_ERROR;
if (ofs > fp->fsize

&& !(fp->flag & 0x02)

) ofs = fp->fsize;

ifptr = fp->fptr;
fp->fptr = 0; fp->csect = 255;
if (ofs > 0) {
csize = (DWORD)fp->fs->csize * 512U;
if (ifptr > 0 &&
(ofs - 1) / csize >= (ifptr - 1) / csize) {
fp->fptr = (ifptr - 1) & ~(csize - 1);
ofs -= fp->fptr;
clust = fp->curr_clust;
} else {
clust = fp->org_clust;

if (clust == 0) {
clust = create_chain(0);
if (clust == 1) goto fk_error;
fp->org_clust = clust;
}

fp->curr_clust = clust;
}
if (clust != 0) {
while (ofs > csize) {

if (fp->flag & 0x02) {
clust = create_chain(clust);
if (clust == 0) {
ofs = csize; break;
}
} else

clust = get_cluster(clust);
if (clust < 2 || clust >= fp->fs->max_clust) goto fk_error;
fp->curr_clust = clust;
fp->fptr += csize;
ofs -= csize;
}
fp->fptr += ofs;
fp->csect = (BYTE)(ofs / 512U);
if (ofs % 512U) fp->csect++;
}
}


if (fp->fptr > fp->fsize) {
fp->fsize = fp->fptr;
fp->flag |= 0x20;
}


return FR_OK;

fk_error:
fp->flag |= 0x80;
return FR_RW_ERROR;
}

# 1214
FRESULT f_opendir (
DIR_E *dj,
const char *path
)
{
FRESULT res;
BYTE *dir;
char fn[8+3+1];


res = auto_mount(&path, 0);
if (res == FR_OK) {
res = trace_path(dj, fn, path, &dir);
if (res == FR_OK) {
if (dir) {
if (dir[11] & 0x10) {
dj->clust =

((DWORD)(WORD)(((WORD)*(volatile BYTE*)((&dir[20])+1)<<8)|(WORD)*(volatile BYTE*)(&dir[20])) << 16) |

(WORD)(((WORD)*(volatile BYTE*)((&dir[26])+1)<<8)|(WORD)*(volatile BYTE*)(&dir[26]));
dj->sect = clust2sect(dj->clust);
dj->index = 2;
} else {
res = FR_NO_FILE;
}
}
dj->id = dj->fs->id;
}
}

return res;
}

# 1255
FRESULT f_readdir (
DIR_E *dj,
FILINFO *finfo
)
{
FRESULT res;
BYTE *dir, c;


res = validate(dj->fs, dj->id);
if (res != FR_OK) return res;

finfo->fname[0] = 0;
while (dj->sect) {
if (!move_window(dj->sect))
return FR_RW_ERROR;
dir = &dj->fs->win[(dj->index & 15) * 32];
c = dir[0];
if (c == 0) break;
if (c != 0xE5 && !(dir[11] & 0x08))
get_fileinfo(finfo, dir);
if (!next_dir_entry(dj)) dj->sect = 0;
if (finfo->fname[0]) break;
}

return FR_OK;
}

# 1291
FRESULT f_stat (
const char *path,
FILINFO *finfo
)
{
FRESULT res;
DIR_E dj;
BYTE *dir;
char fn[8+3+1];


res = auto_mount(&path, 0);
if (res == FR_OK) {
res = trace_path(&dj, fn, path, &dir);
if (res == FR_OK) {
if (dir)
get_fileinfo(finfo, dir);
else
res = FR_INVALID_NAME;
}
}

return res;
}

# 1324
FRESULT f_truncate (
FIL *fp
)
{
FRESULT res;
CLUST ncl;


res = validate(fp->fs, fp->id);
if (res != FR_OK) return res;
if (fp->flag & 0x80) return FR_RW_ERROR;
if (!(fp->flag & 0x02)) return FR_DENIED;

if (fp->fsize > fp->fptr) {
fp->fsize = fp->fptr;
fp->flag |= 0x20;
if (fp->fptr == 0) {
if (!remove_chain(fp->org_clust)) goto ft_error;
fp->org_clust = 0;
} else {
ncl = get_cluster(fp->curr_clust);
if (ncl < 2) goto ft_error;
if (ncl < fp->fs->max_clust) {
if (!put_cluster(fp->curr_clust, (CLUST)0x0FFFFFFF)) goto ft_error;
if (!remove_chain(ncl)) goto ft_error;
}
}
}

return FR_OK;

ft_error:
fp->flag |= 0x80;
return FR_RW_ERROR;
}

# 1367
FRESULT f_getfree (
const char *drv,
DWORD *nclust,
FATFS **fatfs
)
{
FRESULT res;
FATFS *fs;
DWORD n, sect;
CLUST clust;
BYTE fat, f, *p;



res = auto_mount(&drv, 0);
if (res != FR_OK) return res;
*fatfs = fs = FatFs;


if (fs->free_clust <= fs->max_clust - 2) {
*nclust = fs->free_clust;
return FR_OK;
}


fat = fs->fs_type;
n = 0;
if (fat == 1) {
clust = 2;
do {
if ((WORD)get_cluster(clust) == 0) n++;
} while (++clust < fs->max_clust);
} else {
clust = fs->max_clust;
sect = fs->fatbase;
f = 0; p = 0;
do {
if (!f) {
if (!move_window(sect++)) return FR_RW_ERROR;
p = fs->win;
}
if (!1 || fat == 2) {
if ((WORD)(((WORD)*(volatile BYTE*)((p)+1)<<8)|(WORD)*(volatile BYTE*)(p)) == 0) n++;
p += 2; f += 1;
} else {
if ((DWORD)(((DWORD)*(volatile BYTE*)((p)+3)<<24)|((DWORD)*(volatile BYTE*)((p)+2)<<16)|((WORD)*(volatile BYTE*)((p)+1)<<8)|*(volatile BYTE*)(p)) == 0) n++;
p += 4; f += 2;
}
} while (--clust);
}
fs->free_clust = n;

# 1422
*nclust = n;
return FR_OK;
}

# 1433
FRESULT f_unlink (
const char *path
)
{
FRESULT res;
DIR_E dj;
BYTE *dir, *sdir;
DWORD dsect;
char fn[8+3+1];
CLUST dclust;


res = auto_mount(&path, 1);
if (res != FR_OK) return res;
res = trace_path(&dj, fn, path, &dir);
if (res != FR_OK) return res;
if (!dir) return FR_INVALID_NAME;
if (dir[11] & 0x01) return FR_DENIED;
dsect = dj.fs->winsect;
dclust =

((DWORD)(WORD)(((WORD)*(volatile BYTE*)((&dir[20])+1)<<8)|(WORD)*(volatile BYTE*)(&dir[20])) << 16) |

(WORD)(((WORD)*(volatile BYTE*)((&dir[26])+1)<<8)|(WORD)*(volatile BYTE*)(&dir[26]));
if (dir[11] & 0x10) {
dj.clust = dclust;
dj.sect = clust2sect(dclust);
dj.index = 2;
do {
if (!move_window(dj.sect)) return FR_RW_ERROR;
sdir = &dj.fs->win[(dj.index & 15) * 32];
if (sdir[0] == 0) break;
if (sdir[0] != 0xE5 && !(sdir[11] & 0x08))
return FR_DENIED;
} while (next_dir_entry(&dj));
}

if (!move_window(dsect)) return FR_RW_ERROR;
dir[0] = 0xE5;
dj.fs->winflag = 1;
if (!remove_chain(dclust)) return FR_RW_ERROR;

return sync();
}

# 1485
FRESULT f_mkdir (
const char *path
)
{
FRESULT res;
DIR_E dj;
BYTE *dir, *fw, n;
char fn[8+3+1];
DWORD sect, dsect, tim;
CLUST dclust, pclust;


res = auto_mount(&path, 1);
if (res != FR_OK) return res;
res = trace_path(&dj, fn, path, &dir);
if (res == FR_OK) return FR_EXIST;
if (res != FR_NO_FILE) return res;

res = reserve_direntry(&dj, &dir);
if (res != FR_OK) return res;
sect = dj.fs->winsect;
dclust = create_chain(0);
if (dclust == 1) return FR_RW_ERROR;
dsect = clust2sect(dclust);
if (!dsect) return FR_DENIED;
if (!move_window(dsect)) return FR_RW_ERROR;

fw = dj.fs->win;
memset(fw, 0, 512U);
for (n = 1; n < dj.fs->csize; n++) {
if (disk_write(0, fw, ++dsect, 1) != RES_OK)
return FR_RW_ERROR;
}

memset(&fw[0], ' ', 8+3);
fw[0] = '.';
fw[11] = 0x10;
tim = get_fattime();
*(volatile BYTE*)(&fw[22])=(BYTE)(tim); *(volatile BYTE*)((&fw[22])+1)=(BYTE)((WORD)(tim)>>8); *(volatile BYTE*)((&fw[22])+2)=(BYTE)((DWORD)(tim)>>16); *(volatile BYTE*)((&fw[22])+3)=(BYTE)((DWORD)(tim)>>24);
memcpy(&fw[32], &fw[0], 32); fw[33] = '.';
pclust = dj.sclust;

*(volatile BYTE*)(&fw[ 20])=(BYTE)(dclust >> 16); *(volatile BYTE*)((&fw[ 20])+1)=(BYTE)((WORD)(dclust >> 16)>>8);
if (dj.fs->fs_type == 3 && pclust == dj.fs->dirbase) pclust = 0;
*(volatile BYTE*)(&fw[32+20])=(BYTE)(pclust >> 16); *(volatile BYTE*)((&fw[32+20])+1)=(BYTE)((WORD)(pclust >> 16)>>8);

*(volatile BYTE*)(&fw[ 26])=(BYTE)(dclust); *(volatile BYTE*)((&fw[ 26])+1)=(BYTE)((WORD)(dclust)>>8);
*(volatile BYTE*)(&fw[32+26])=(BYTE)(pclust); *(volatile BYTE*)((&fw[32+26])+1)=(BYTE)((WORD)(pclust)>>8);
dj.fs->winflag = 1;

if (!move_window(sect)) return FR_RW_ERROR;
memset(&dir[0], 0, 32);
memcpy(&dir[0], fn, 8+3);
dir[12] = fn[11];
dir[11] = 0x10;
*(volatile BYTE*)(&dir[22])=(BYTE)(tim); *(volatile BYTE*)((&dir[22])+1)=(BYTE)((WORD)(tim)>>8); *(volatile BYTE*)((&dir[22])+2)=(BYTE)((DWORD)(tim)>>16); *(volatile BYTE*)((&dir[22])+3)=(BYTE)((DWORD)(tim)>>24);
*(volatile BYTE*)(&dir[26])=(BYTE)(dclust); *(volatile BYTE*)((&dir[26])+1)=(BYTE)((WORD)(dclust)>>8);

*(volatile BYTE*)(&dir[20])=(BYTE)(dclust >> 16); *(volatile BYTE*)((&dir[20])+1)=(BYTE)((WORD)(dclust >> 16)>>8);


return sync();
}

# 1556
FRESULT f_chmod (
const char *path,
BYTE value,
BYTE mask
)
{
FRESULT res;
DIR_E dj;
BYTE *dir;
char fn[8+3+1];


res = auto_mount(&path, 1);
if (res == FR_OK) {
res = trace_path(&dj, fn, path, &dir);
if (res == FR_OK) {
if (!dir) {
res = FR_INVALID_NAME;
} else {
mask &= 0x01|0x02|0x04|0x20;
dir[11] = (value & mask) | (dir[11] & (BYTE)~mask);
res = sync();
}
}
}
return res;
}

# 1591
FRESULT f_utime (
const char *path,
const FILINFO *finfo
)
{
FRESULT res;
DIR_E dj;
BYTE *dir;
char fn[8+3+1];


res = auto_mount(&path, 1);
if (res == FR_OK) {
res = trace_path(&dj, fn, path, &dir);
if (res == FR_OK) {
if (!dir) {
res = FR_INVALID_NAME;
} else {
*(volatile BYTE*)(&dir[22])=(BYTE)(finfo->ftime); *(volatile BYTE*)((&dir[22])+1)=(BYTE)((WORD)(finfo->ftime)>>8);
*(volatile BYTE*)(&dir[24])=(BYTE)(finfo->fdate); *(volatile BYTE*)((&dir[24])+1)=(BYTE)((WORD)(finfo->fdate)>>8);
res = sync();
}
}
}
return res;
}

# 1625
FRESULT f_rename (
const char *path_old,
const char *path_new
)
{
FRESULT res;
DWORD sect_old;
BYTE *dir_old, *dir_new, direntry[32-11];
DIR_E dj;
char fn[8+3+1];


res = auto_mount(&path_old, 1);
if (res != FR_OK) return res;

res = trace_path(&dj, fn, path_old, &dir_old);
if (res != FR_OK) return res;
if (!dir_old) return FR_NO_FILE;
sect_old = dj.fs->winsect;
memcpy(direntry, &dir_old[11], 32-11);

res = trace_path(&dj, fn, path_new, &dir_new);
if (res == FR_OK) return FR_EXIST;
if (res != FR_NO_FILE) return res;
res = reserve_direntry(&dj, &dir_new);
if (res != FR_OK) return res;

memcpy(&dir_new[11], direntry, 32-11);
memcpy(&dir_new[0], fn, 8+3);
dir_new[12] = fn[11];
dj.fs->winflag = 1;

if (!move_window(sect_old)) return FR_RW_ERROR;
dir_old[0] = 0xE5;

return sync();
}

# 1729
char* fgets (
char* buff,
int len,
FIL* fil
)
{
int i = 0;
char *p = buff;
UINT rc;


while (i < len - 1) {
f_read(fil, p, 1, &rc);
if (rc != 1) break;

# 1746
i++;
if (*p++ == '\n') break;
}
*p = 0;
return i ? buff : 0;
}

# 7 "C:\Program Files (x86)\Microchip\xc8\v1.45\include\stdarg.h"
typedef void * va_list[1];

#pragma intrinsic(__va_start)
extern void * __va_start(void);

#pragma intrinsic(__va_arg)
extern void * __va_arg(void *, ...);

# 1760 "bibliotecas/tff.c"
int fputc (
int chr,
FIL* fil
)
{
UINT bw;
char c;

# 1772
if (!fil) {

return chr;
}
c = (char)chr;
f_write(fil, &c, 1, &bw);
return bw ? chr : -1;
}

# 1787
int fputs (
const char* str,
FIL* fil
)
{
int n;


for (n = 0; *str; str++, n++) {
if (fputc(*str, fil) == -1) return -1;
}
return n;
}

# 1807
int fprintf (
FIL* fil,
const char* str,
...
)
{
va_list arp;
UCHAR c, f, r;
ULONG val;
char s[16];
int i, w, res, cc;


*arp = __va_start();

for (cc = res = 0; cc != -1; res += cc) {
c = *str++;
if (c == 0) break;
if (c != '%') {
cc = fputc(c, fil);
if (cc != -1) cc = 1;
continue;
}
w = f = 0;
c = *str++;
if (c == '0') {
f = 1; c = *str++;
}
while (c >= '0' && c <= '9') {
w = w * 10 + (c - '0');
c = *str++;
}
if (c == 'l') {
f |= 2; c = *str++;
}
if (c == 's') {
cc = fputs((*(char* *)__va_arg((*(char* **)arp), (char*)0)), fil);
continue;
}
if (c == 'c') {
cc = fputc((*(char *)__va_arg((*(char **)arp), (char)0)), fil);
if (cc != -1) cc = 1;
continue;
}
r = 0;
if (c == 'd') r = 10;
if (c == 'u') r = 10;
if (c == 'X') r = 16;
if (r == 0) break;
if (f & 2) {
val = (ULONG)(*(long *)__va_arg((*(long **)arp), (long)0));
} else {
val = (c == 'd') ? (ULONG)(long)(*(int *)__va_arg((*(int **)arp), (int)0)) : (ULONG)(*(unsigned int *)__va_arg((*(unsigned int **)arp), (unsigned int)0));
}

if (c == 'd') {
if (val >= 0x80000000) {
val = 0 - val;
f |= 4;
}
}
i = sizeof(s) - 1; s[i] = 0;
do {
c = (UCHAR)(val % r + '0');
if (c > '9') c += 7;
s[--i] = c;
val /= r;
} while (i && val);
if (i && (f & 4)) s[--i] = '-';
w = sizeof(s) - 1 - w;
while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';
cc = fputs(&s[i], fil);
}

;
return (cc == -1) ? cc : res;
}

